<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>GTFS Fusion</title>
  <script>
    // Define exports for fflate UMD compatibility
    if (typeof exports === 'undefined') {
      var exports = {};
    }
  </script>
  <script src="https://unpkg.com/fflate@0.8.1/umd/index.js"></script>
  <script>
    // Expose fflate globally from exports
    if (typeof exports !== 'undefined' && exports.unzip) {
      window.fflate = exports;
    }
  </script>
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.9.4/leaflet.min.css" />
  <script src="https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.9.4/leaflet.min.js"></script>
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/leaflet.markercluster/1.5.3/MarkerCluster.css" />
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/leaflet.markercluster/1.5.3/MarkerCluster.Default.css" />
<script src="https://cdnjs.cloudflare.com/ajax/libs/leaflet.markercluster/1.5.3/leaflet.markercluster.js"></script>
  <style>
    body { margin:0; font-family: system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial; }
    #root { height:100vh; }
    .routes-header{ display:flex; align-items:center; justify-content:space-between; margin-bottom:12px; }
    .routes-grid{ display:grid; grid-template-columns: repeat(auto-fill, minmax(96px, 1fr)); gap:12px; }
    .route-card{ display:flex; align-items:center; justify-content:center; height:48px; background:#eff6ff; border:1px solid #e6eefb; color:#0f172a; font-weight:600; border-radius:6px; cursor:pointer; transition:background .12s, transform .06s; gap:8px; padding:0 8px; text-align:center; }
    .route-card:hover{ background:#e0f2fe; transform:translateY(-1px); }
    .agency-group{ margin-bottom:28px; }
    .agency-title{ font-weight:700; margin:12px 0 8px; color:#334155; }
    .progress-bar { height:12px; background:linear-gradient(90deg,#60a5fa,#3b82f6); border-radius:8px; transition:width 200ms ease; }
.progress-badge {
  position: absolute;
  top: -26px;
  right: 0;
  background: linear-gradient(135deg, #3b82f6, #2563eb);
  color: white;
  padding: 3px 10px;
  border-radius: 6px;
  font-size: 11px;
  font-weight: 700;
  box-shadow: 0 2px 6px rgba(59, 130, 246, 0.3);
  letter-spacing: 0.5px;
}
@keyframes slow-blink {
  0%, 100% { opacity: 1; }
  50% { opacity: 0.3; }
}
.route-title {
  display: -webkit-box;
  -webkit-line-clamp: 2;
  -webkit-box-orient: vertical;
  overflow: hidden;
  text-overflow: ellipsis;
  word-break: break-word;
  white-space: normal;
  font-size: 1.125rem; /* ~18px — dopasuj jeśli chcesz mniejszy/wiekszy */
  line-height: 1.15;
  max-height: calc(1.15em * 2);
  min-width: 0;        /* bardzo ważne w flex-context */
  flex: 1 1 auto;
}
/* wklej do <style> (np. po .route-card-title) */
.route-badge {
  display: inline-flex;
  align-items: center;
  justify-content: center;
  border: 2px solid #111;       /* czarna ramka */
  background: #fff;             /* biały środek */
  color: #111;
  font-weight: 900;
  font-size: 1.25rem;
  min-width: 48px;
  height: 40px;
  padding: 0 0.5rem;
  border-radius: 6px;
  margin-right: 0.75rem;
  box-sizing: border-box;
  line-height: 1;
}
/* badge + title: inline-flex, nie zawija się wewnętrznie; title może się kurczyć */
.header-with-badge {
  display: inline-flex;
  align-items: center;
  gap: 0.5rem;
  flex-wrap: nowrap;
  min-width: 0;
}
	.routes-options { position: absolute; right: 4px; top: calc(100% + 6px); background: white; border: 1px solid #e5e7eb; padding: 8px; border-radius: 6px; box-shadow: 0 6px 18px rgba(15,23,42,0.08); z-index: 30; }
 /* kontener nagłówka - musi być relative, żeby controls absolute działało względem niego */
.header-row {
  position: relative;
  display: flex;
  align-items: center;
  gap: 0.5rem;
}

/* lewa część (badge + title) */
.header-left {
  min-width: 0;
  display: flex;
  align-items: center;
  gap: 0.5rem;
  /* pozwól lewemu blokowi rozszerzać się tylko do dostępnego miejsca */
  flex: 0 1 auto;
}

/* prawy kontener: absolutnie przytwierdzony do prawej */
.title-controls {
  position: absolute;
  right: 0px;              /* dostosuj odsunięcie od prawej krawędzi kontenera */
  top: 50%;
  transform: translateY(-50%);
  display: flex;
  align-items: center;
  gap: 0.5rem;
  white-space: nowrap;
  z-index: 2;
}

/* upewnij się, że selecty nie rozciągają się na 100% */
.title-controls > select {
  width: auto !important;
  display: inline-block;
  min-width: 160px; /* dopasuj szerokość */
}
*,
::before,
::after {
  --tw-border-spacing-x:0;
  --tw-border-spacing-y:0;
  --tw-translate-x:0;
  --tw-translate-y:0;
  --tw-rotate:0;
  --tw-skew-x:0;
  --tw-skew-y:0;
  --tw-scale-x:1;
  --tw-scale-y:1;
  --tw-pan-x: ;
  --tw-pan-y: ;
  --tw-pinch-zoom: ;
  --tw-scroll-snap-strictness:proximity;
  --tw-gradient-from-position: ;
  --tw-gradient-via-position: ;
  --tw-gradient-to-position: ;
  --tw-ordinal: ;
  --tw-slashed-zero: ;
  --tw-numeric-figure: ;
  --tw-numeric-spacing: ;
  --tw-numeric-fraction: ;
  --tw-ring-inset: ;
  --tw-ring-offset-width:0px;
  --tw-ring-offset-color:#fff;
  --tw-ring-color:rgb(59 130 246 / 0.5);
  --tw-ring-offset-shadow:0 0 #0000;
  --tw-ring-shadow:0 0 #0000;
  --tw-shadow:0 0 #0000;
  --tw-shadow-colored:0 0 #0000;
  --tw-blur: ;
  --tw-brightness: ;
  --tw-contrast: ;
  --tw-grayscale: ;
  --tw-hue-rotate: ;
  --tw-invert: ;
  --tw-saturate: ;
  --tw-sepia: ;
  --tw-drop-shadow: ;
  --tw-backdrop-blur: ;
  --tw-backdrop-brightness: ;
  --tw-backdrop-contrast: ;
  --tw-backdrop-grayscale: ;
  --tw-backdrop-hue-rotate: ;
  --tw-backdrop-invert: ;
  --tw-backdrop-opacity: ;
  --tw-backdrop-saturate: ;
  --tw-backdrop-sepia: ;
  --tw-contain-size: ;
  --tw-contain-layout: ;
  --tw-contain-paint: ;
  --tw-contain-style: 
}
::backdrop {
  --tw-border-spacing-x:0;
  --tw-border-spacing-y:0;
  --tw-translate-x:0;
  --tw-translate-y:0;
  --tw-rotate:0;
  --tw-skew-x:0;
  --tw-skew-y:0;
  --tw-scale-x:1;
  --tw-scale-y:1;
  --tw-pan-x: ;
  --tw-pan-y: ;
  --tw-pinch-zoom: ;
  --tw-scroll-snap-strictness:proximity;
  --tw-gradient-from-position: ;
  --tw-gradient-via-position: ;
  --tw-gradient-to-position: ;
  --tw-ordinal: ;
  --tw-slashed-zero: ;
  --tw-numeric-figure: ;
  --tw-numeric-spacing: ;
  --tw-numeric-fraction: ;
  --tw-ring-inset: ;
  --tw-ring-offset-width:0px;
  --tw-ring-offset-color:#fff;
  --tw-ring-color:rgb(59 130 246 / 0.5);
  --tw-ring-offset-shadow:0 0 #0000;
  --tw-ring-shadow:0 0 #0000;
  --tw-shadow:0 0 #0000;
  --tw-shadow-colored:0 0 #0000;
  --tw-blur: ;
  --tw-brightness: ;
  --tw-contrast: ;
  --tw-grayscale: ;
  --tw-hue-rotate: ;
  --tw-invert: ;
  --tw-saturate: ;
  --tw-sepia: ;
  --tw-drop-shadow: ;
  --tw-backdrop-blur: ;
  --tw-backdrop-brightness: ;
  --tw-backdrop-contrast: ;
  --tw-backdrop-grayscale: ;
  --tw-backdrop-hue-rotate: ;
  --tw-backdrop-invert: ;
  --tw-backdrop-opacity: ;
  --tw-backdrop-saturate: ;
  --tw-backdrop-sepia: ;
  --tw-contain-size: ;
  --tw-contain-layout: ;
  --tw-contain-paint: ;
  --tw-contain-style: 
}
/* ! tailwindcss v3.4.17 | MIT License | https://tailwindcss.com */*,
::after,
::before {
  box-sizing:border-box;
  border-width:0;
  border-style:solid;
  border-color:#e5e7eb
}
::after,
::before {
  --tw-content:''
}
:host,
html {
  line-height:1.5;
  -webkit-text-size-adjust:100%;
  -moz-tab-size:4;
  tab-size:4;
  font-family:ui-sans-serif, system-ui, sans-serif, "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol", "Noto Color Emoji";
  font-feature-settings:normal;
  font-variation-settings:normal;
  -webkit-tap-highlight-color:transparent
}
body {
  margin:0;
  line-height:inherit
}
hr {
  height:0;
  color:inherit;
  border-top-width:1px
}
abbr:where([title]) {
  -webkit-text-decoration:underline dotted;
  text-decoration:underline dotted
}
h1,
h2,
h3,
h4,
h5,
h6 {
  font-size:inherit;
  font-weight:inherit
}
a {
  color:inherit;
  text-decoration:inherit
}
b,
strong {
  font-weight:bolder
}
code,
kbd,
pre,
samp {
  font-family:ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
  font-feature-settings:normal;
  font-variation-settings:normal;
  font-size:1em
}
small {
  font-size:80%
}
sub,
sup {
  font-size:75%;
  line-height:0;
  position:relative;
  vertical-align:baseline
}
sub {
  bottom:-.25em
}
sup {
  top:-.5em
}
table {
  text-indent:0;
  border-color:inherit;
  border-collapse:collapse
}
button,
input,
optgroup,
select,
textarea {
  font-family:inherit;
  font-feature-settings:inherit;
  font-variation-settings:inherit;
  font-size:100%;
  font-weight:inherit;
  line-height:inherit;
  letter-spacing:inherit;
  color:inherit;
  margin:0;
  padding:0
}
button,
select {
  text-transform:none
}
button,
input:where([type=button]),
input:where([type=reset]),
input:where([type=submit]) {
  -webkit-appearance:button;
  background-color:transparent;
  background-image:none
}
:-moz-focusring {
  outline:auto
}
:-moz-ui-invalid {
  box-shadow:none
}
progress {
  vertical-align:baseline
}
::-webkit-inner-spin-button,
::-webkit-outer-spin-button {
  height:auto
}
[type=search] {
  -webkit-appearance:textfield;
  outline-offset:-2px
}
::-webkit-search-decoration {
  -webkit-appearance:none
}
::-webkit-file-upload-button {
  -webkit-appearance:button;
  font:inherit
}
summary {
  display:list-item
}
blockquote,
dd,
dl,
figure,
h1,
h2,
h3,
h4,
h5,
h6,
hr,
p,
pre {
  margin:0
}
fieldset {
  margin:0;
  padding:0
}
legend {
  padding:0
}
menu,
ol,
ul {
  list-style:none;
  margin:0;
  padding:0
}
dialog {
  padding:0
}
textarea {
  resize:vertical
}
input::placeholder,
textarea::placeholder {
  opacity:1;
  color:#9ca3af
}
[role=button],
button {
  cursor:pointer
}
:disabled {
  cursor:default
}
audio,
canvas,
embed,
iframe,
img,
object,
svg,
video {
  display:block;
  vertical-align:middle
}
img,
video {
  max-width:100%;
  height:auto
}
[hidden]:where(:not([hidden=until-found])) {
  display:none
}
.sticky {
  position:sticky
}
.left-0 {
  left:0px
}
.top-0 {
  top:0px
}
.z-10 {
  z-index:10
}
.mx-auto {
  margin-left:auto;
  margin-right:auto
}
.mb-4 {
  margin-bottom:1rem
}
.mb-0 {
  margin-bottom:0px
}
.mt-4 {
  margin-top:1rem
}
.flex {
  display:flex
}
.inline-flex {
  display:inline-flex
}
.hidden {
  display:none
}
.h-screen {
  height:100vh
}
.h-12 {
  height:3rem
}
.w-12 {
  width:3rem
}
.max-w-6xl {
  max-width:72rem
}
.flex-1 {
  flex:1 1 0%
}
@keyframes spin {
  to {
    transform:rotate(360deg)
  }
}
.animate-spin {
  animation:spin 1s linear infinite
}
.cursor-pointer {
  cursor:pointer
}
.flex-col {
  flex-direction:column
}
.items-center {
  align-items:center
}
.justify-center {
  justify-content:center
}
.gap-4 {
  gap:1rem
}
.overflow-auto {
  overflow:auto
}
.overflow-x-auto {
  overflow-x:auto
}
.whitespace-nowrap {
  white-space:nowrap
}
.rounded-lg {
  border-radius:0.5rem
}
.rounded {
  border-radius:0.25rem
}
.rounded-full {
  border-radius:9999px
}
.border {
  border-width:1px
}
.border-b {
  border-bottom-width:1px
}
.border-b-2 {
  border-bottom-width:2px
}
.border-blue-600 {
  --tw-border-opacity:1;
  border-color:rgb(37 99 235 / var(--tw-border-opacity, 1))
}
.bg-gray-50 {
  --tw-bg-opacity:1;
  background-color:rgb(249 250 251 / var(--tw-bg-opacity, 1))
}
.bg-orange-500 {
  --tw-bg-opacity:1;
  background-color:rgb(249 115 22 / var(--tw-bg-opacity, 1))
}
.bg-white {
  --tw-bg-opacity:1;
  background-color:rgb(255 255 255 / var(--tw-bg-opacity, 1))
}
.bg-red-500 {
  --tw-bg-opacity:1;
  background-color:rgb(239 68 68 / var(--tw-bg-opacity, 1))
}
.bg-blue-500 {
  --tw-bg-opacity:1;
  background-color:rgb(59 130 246 / var(--tw-bg-opacity, 1))
}
.bg-gray-200 {
  --tw-bg-opacity:1;
  background-color:rgb(229 231 235 / var(--tw-bg-opacity, 1))
}
.p-1 {
  padding:0.25rem
}
.p-3 {
  padding:0.75rem
}
.p-4 {
  padding:1rem
}
.px-4 {
  padding-left:1rem;
  padding-right:1rem
}
.px-6 {
  padding-left:1.5rem;
  padding-right:1.5rem
}
.py-3 {
  padding-top:0.75rem;
  padding-bottom:0.75rem
}
.px-3 {
  padding-left:0.75rem;
  padding-right:0.75rem
}
.py-1 {
  padding-top:0.25rem;
  padding-bottom:0.25rem
}
.py-2 {
  padding-top:0.5rem;
  padding-bottom:0.5rem
}
.text-left {
  text-align:left
}
.text-center {
  text-align:center
}
.text-lg {
  font-size:1.125rem;
  line-height:1.75rem
}
.text-xl {
  font-size:1.25rem;
  line-height:1.75rem
}
.text-2xl {
  font-size:1.5rem;
  line-height:2rem
}
.text-sm {
  font-size:13.75px;
  line-height:1.25rem
}
.text-xs {
  font-size:0.75rem;
  line-height:1rem
}
.font-bold {
  font-weight:700
}
.font-medium {
  font-weight:500
}
.font-semibold {
  font-weight:600
}
.text-blue-600 {
  --tw-text-opacity:1;
  color:rgb(37 99 235 / var(--tw-text-opacity, 1))
}
.text-white {
  --tw-text-opacity:1;
  color:rgb(255 255 255 / var(--tw-text-opacity, 1))
}
.text-gray-600 {
  --tw-text-opacity:1;
  color:rgb(75 85 99 / var(--tw-text-opacity, 1))
}
.shadow-sm {
  --tw-shadow:0 1px 2px 0 rgb(0 0 0 / 0.05);
  --tw-shadow-colored:0 1px 2px 0 var(--tw-shadow-color);
  box-shadow:var(--tw-ring-offset-shadow, 0 0 #0000), var(--tw-ring-shadow, 0 0 #0000), var(--tw-shadow)
}
.hover\:bg-orange-600:hover {
  --tw-bg-opacity:1;
  background-color:rgb(234 88 12 / var(--tw-bg-opacity, 1))
}
.hover\:bg-red-600:hover {
  --tw-bg-opacity:1;
  background-color:rgb(220 38 38 / var(--tw-bg-opacity, 1))
}
.hover\:bg-blue-50:hover {
  --tw-bg-opacity:1;
  background-color:rgb(239 246 255 / var(--tw-bg-opacity, 1))
}
.hover\:bg-blue-600:hover {
  --tw-bg-opacity:1;
  background-color:rgb(37 99 235 / var(--tw-bg-opacity, 1))
}
.hover\:bg-gray-300:hover {
  --tw-bg-opacity:1;
  background-color:rgb(209 213 219 / var(--tw-bg-opacity, 1))
}
.hover\:bg-gray-50:hover {
  --tw-bg-opacity:1;
  background-color:rgb(249 250 251 / var(--tw-bg-opacity, 1))
}

/* Neutralna kolorystyka clusterów */
.marker-cluster-neutral {
  background-color: rgba(100, 116, 139, 0.6);
}
.marker-cluster-neutral div {
  background-color: rgba(71, 85, 105, 0.8);
  color: white;
}
.marker-cluster-neutral.marker-cluster-small {
  background-color: rgba(148, 163, 184, 0.6);
}
.marker-cluster-neutral.marker-cluster-small div {
  background-color: rgba(100, 116, 139, 0.8);
}

/* FIX #5: Tooltips for timetable departure times */
.time-cell-with-tooltip {
  position: relative;
  cursor: help;
}

.time-cell-with-tooltip .tooltip-content {
  visibility: hidden;
  opacity: 0;
  position: fixed !important;
  z-index: 99999 !important;
  background-color: #1f2937;
  color: #fff;
  padding: 8px 12px;
  border-radius: 6px;
  font-size: 12px;
  line-height: 1.4;
  white-space: nowrap;
  pointer-events: none !important;
  transition: opacity 0.2s, visibility 0.2s;
  box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
  max-width: 300px;
}

.time-cell-with-tooltip:hover .tooltip-content {
  visibility: visible !important;
  opacity: 1 !important;
}


 </style>
</head>
<body>
  <div id="root"></div>
  <script>
// ═══════════════════════════════════════════════════════════════
// GTFS Fusion - Single Page Application
// ═══════════════════════════════════════════════════════════════
// For architectural documentation and refactoring notes, see REFACTORING.md
// ═══════════════════════════════════════════════════════════════

// ═══════════════════════════════════════════════════════════════
// 1. CONSTANTS & CONFIGURATION
// ═══════════════════════════════════════════════════════════════
const DAY_NAMES = ['sunday','monday','tuesday','wednesday','thursday','friday','saturday'];
const SUNDAY = 0, WEDNESDAY = 3, SATURDAY = 6;
const icons = { upload: (size=24) => `<svg width="${size}" height="${size}" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4M17 8l-5-5-5 5M12 3v12" /></svg>` };
    const VIEW = {
      LOADING: 'loading',
      ERROR: 'error',
      UPLOAD: 'upload',
      ROUTES_LIST: 'routes_list',
      STOPS_LIST: 'stops_list',
      STOP_DETAIL: 'stop_detail',
      ROUTE_TIMETABLE: 'route_timetable'
    };

    const KEY_ALIAS = {
      'route id':'route_id','routeid':'route_id','route_id':'route_id','route short name':'route_short_name','route_short_name':'route_short_name',
      'route long name':'route_long_name','route_long_name':'route_long_name','trip id':'trip_id','tripid':'trip_id','trip_id':'trip_id',
      'service id':'service_id','serviceid':'service_id','service_id':'service_id','stop id':'stop_id','stopid':'stop_id','stop_id':'stop_id',
      'stop sequence':'stop_sequence','stop_sequence':'stop_sequence','arrival time':'arrival_time','arrival_time':'arrival_time',
      'departure time':'departure_time','departure_time':'departure_time','pickup type':'pickup_type','pickup_type':'pickup_type',
      'drop off type':'drop_off_type','drop_off_type':'drop_off_type','stop lat':'stop_lat','stop_lat':'stop_lat',
      'stop lon':'stop_lon','stop_lon':'stop_lon','direction id':'direction_id','direction_id':'direction_id',
      'trip headsign':'trip_headsign','trip_headsign':'trip_headsign','start date':'start_date','start_date':'start_date',
      'end date':'end_date','end_date':'end_date','monday':'monday','tuesday':'tuesday','wednesday':'wednesday','thursday':'thursday',
      'friday':'friday','saturday':'saturday','sunday':'sunday','exception type':'exception_type','exception_type':'exception_type','date':'date'
    };

    // Basic GTFS route_type mapping
    const ROUTE_TYPE_META_BASIC = {
      0: { label: 'Tram', color: '#f59e0b', weight: 3, iconSvg: 'M6 3v13' },
      1: { label: 'Subway', color: '#ef4444', weight: 3, iconSvg: 'M3 6h18v12H3z' },
      2: { label: 'Rail', color: '#10b981', weight: 3, iconSvg: 'M4 6h16' },
      3: { label: 'Bus', color: '#2563eb', weight: 3, iconSvg: 'M5 6h14v8H5z' },
      4: { label: 'Ferry', color: '#0ea5a4', weight: 3, iconSvg: 'M2 16s3-4 10-4 10 4 10 4' },
      5: { label: 'Cable car', color: '#7c3aed', weight: 3, iconSvg: 'M4 6l8-4 8 4' },
      6: { label: 'Gondola', color: '#06b6d4', weight: 3, iconSvg: 'M4 6c4 0 8-4 12 0' },
      7: { label: 'Funicular', color: '#f97316', weight: 3, iconSvg: 'M3 18h18' },
      11:{ label: 'Trolleybus', color: '#8b5cf6', weight: 3, iconSvg: 'M4 6h16' },
      12:{ label: 'Monorail', color: '#06b6d4', weight: 3, iconSvg: 'M2 12h20' }
    };

    // Full extended GTFS route types from Google's extended-route-types reference.
    const ROUTE_TYPE_META_EXTENDED = {
100: { label: 'Railway service', color:'#10b981', weight:4 },          // ← ZMIEŃ
101: { label: 'High speed rail service', color:'#10b981', weight:4 },  // ← ZMIEŃ
102: { label: 'Long distance trains', color:'#10b981', weight:4 },     // ← ZMIEŃ
103: { label: 'Inter regional rail service', color:'#10b981', weight:4 }, // ← ZMIEŃ
      104: { label: 'Car transport rail service', color:'#6b7280', weight:3 }, 105: { label: 'Sleeper rail service', color:'#6b7280', weight:3 },
      106: { label: 'Regional rail service', color:'#059669', weight:4 }, 107: { label: 'Tourist railway service', color:'#f59e0b', weight:3 },
      108: { label: 'Rail shuttle (within complex)', color:'#9ca3af', weight:2 }, 109: { label: 'Suburban railway', color:'#059669', weight:4 },
      110: { label: 'Replacement rail service', color:'#9ca3af', weight:3 }, 111: { label: 'Special rail service', color:'#6b7280', weight:3 },
      112: { label: 'Lorry transport rail service', color:'#6b7280', weight:3 },
      113: { label: 'All rail services', color:'#10b981', weight:4 }, 
      114: { label: 'Cross-country rail service', color:'#10b981', weight: 4 }, 115: { label: 'Vehicle transport rail service', color:'#6b7280', weight:3 },
      116: { label: 'Rack and pinion railway', color:'#f97316', weight:3 }, 117: { label: 'Additional rail service', color:'#0b74de', weight:3 },

      200: { label: 'Coach service', color:'#1f2937', weight:3 }, 201: { label: 'International coach service', color:'#374151', weight:3 },
      202: { label: 'National coach service', color:'#374151', weight:3 }, 203: { label: 'Shuttle coach service', color:'#6b7280', weight:3 },
      204: { label: 'Regional coach service', color:'#374151', weight:3 }, 205: { label: 'Special coach service', color:'#6b7280', weight:3 },
      206: { label: 'Sightseeing coach service', color:'#f59e0b', weight:3 }, 207: { label: 'Tourist coach service', color:'#f59e0b', weight:3 },
      208: { label: 'Commuter coach service', color:'#2563eb', weight:3 }, 209: { label: 'All coach services', color:'#1f2937', weight:3 },

      300: { label: 'Suburban railway service', color:'#059669', weight:3 }, 400: { label: 'Urban railway service', color:'#ef4444', weight:3 },
      401: { label: 'Metro service', color:'#ef4444', weight:3 }, 402: { label: 'Underground service', color:'#ef4444', weight:3 },
      403: { label: 'Urban railway service (other)', color:'#ef4444', weight:3 }, 404: { label: 'All urban railway services', color:'#ef4444', weight:3 },
      405: { label: 'Monorail', color:'#7c3aed', weight:3 },

      500: { label: 'Water transport service', color:'#0ea5a4', weight:3 }, 501: { label: 'International car ferry service', color:'#0ea5a4', weight:3 },
      502: { label: 'National car ferry service', color:'#0ea5a4', weight:3 }, 503: { label: 'Regional car ferry service', color:'#0ea5a4', weight:3 },
      504: { label: 'Local car ferry service', color:'#0ea5a4', weight:3 }, 505: { label: 'International passenger ferry service', color:'#0ea5a4', weight:3 },
      506: { label: 'National passenger ferry service', color:'#0ea5a4', weight:3 }, 507: { label: 'Regional passenger ferry service', color:'#0ea5a4', weight:3 },
      508: { label: 'Local passenger ferry service', color:'#0ea5a4', weight:3 }, 509: { label: 'Post boat service', color:'#0ea5a4', weight:3 },
      510: { label: 'Water taxi', color:'#0ea5a4', weight:3 }, 511: { label: 'River bus service', color:'#0ea5a4', weight:3 },
      512: { label: 'Scheduled ferry service', color:'#0ea5a4', weight:3 }, 513: { label: 'Shuttle ferry service', color:'#0ea5a4', weight:3 },
      514: { label: 'All water transport services', color:'#0ea5a4', weight:3 },

      1100: { label: 'Air service', color:'#6b7280', weight:2 }, 1101: { label: 'International air service', color:'#6b7280', weight:2 },
      1102: { label: 'Domestic air service', color:'#6b7280', weight:2 }, 1103: { label: 'Intercontinental air service', color:'#6b7280', weight:2 },
      1104: { label: 'Domestic scheduled air service', color:'#6b7280', weight:2 }, 1105: { label: 'Shuttle air service', color:'#6b7280', weight:2 },
      1106: { label: 'Intercontinental charter air service', color:'#6b7280', weight:2 }, 1107: { label: 'International charter air service', color:'#6b7280', weight:2 },
      1108: { label: 'Round-trip charter air service', color:'#6b7280', weight:2 }, 1109: { label: 'Sightseeing air service', color:'#f59e0b', weight:2 },
      1110: { label: 'Helicopter air service', color:'#6b7280', weight:2 }, 1111: { label: 'Domestic charter air service', color:'#6b7280', weight:2 },
      1112: { label: 'Schengen-area air service', color:'#6b7280', weight:2 }, 1113: { label: 'Airship service', color:'#6b7280', weight:2 },
      1114: { label: 'All air services', color:'#6b7280', weight:2 },

      700: { label: 'Bus service', color:'#2563eb', weight:3 }, 701: { label: 'Regional bus service', color:'#2563eb', weight:3 },
      702: { label: 'Express bus service', color:'#1d4ed8', weight:3 }, 703: { label: 'Stopping bus service', color:'#2563eb', weight:3 },
      704: { label: 'Local bus service', color:'#2563eb', weight:3 }, 705: { label: 'Night bus service', color:'#0f172a', weight:3 },
      706: { label: 'Post bus service', color:'#6b7280', weight:3 }, 707: { label: 'Special needs bus', color:'#6b7280', weight:3 },
      708: { label: 'Mobility bus service', color:'#6b7280', weight:3 }, 709: { label: 'Mobility bus for registered disabled', color:'#6b7280', weight:3 },
      710: { label: 'Sightseeing bus', color:'#f59e0b', weight:3 }, 711: { label: 'Shuttle bus', color:'#6b7280', weight:3 },
      712: { label: 'School bus', color:'#6b7280', weight:3 }, 713: { label: 'School and public service bus', color:'#6b7280', weight:3 },
      714: { label: 'Rail replacement bus service', color:'#9ca3af', weight:3 }, 715: { label: 'Demand and response bus service', color:'#6b7280', weight:3 },
      716: { label: 'All bus services', color:'#2563eb', weight:3 },

      800: { label: 'Trolleybus service', color:'#8b5cf6', weight:3 },

      900: { label: 'Tram service', color:'#f59e0b', weight:3 }, 901: { label: 'City tram service', color:'#f59e0b', weight:3 },
      902: { label: 'Local tram service', color:'#f59e0b', weight:3 }, 903: { label: 'Regional tram service', color:'#f59e0b', weight:3 },
      904: { label: 'Sightseeing tram service', color:'#f59e0b', weight:3 }, 905: { label: 'Shuttle tram service', color:'#f59e0b', weight:3 },
      906: { label: 'All tram services', color:'#f59e0b', weight:3 },

      1300: { label: 'Telecabin / cable car', color:'#7c3aed', weight:3 }, 1301: { label: 'Gondola lift', color:'#06b6d4', weight:3 }
    };

// --- START: Canonical route type collector (use this AFTER ROUTE_TYPE_META_EXTENDED)
const CANONICAL_CATEGORIES = {
  metro: { label: 'Metro', order: 10 },
  tram: { label: 'Tramwaj', order: 20 },
  trolleybus: { label: 'Trolejbus', order: 30 },
  bus: { label: 'Autobus', order: 40 },
  rail: { label: 'Kolej', order: 50 },
  other: { label: 'Inne', order: 60 },
  coach: { label: 'Autokar', order: 70 },
  ferry: { label: 'Promy', order: 80 },
  air: { label: 'Samolot', order: 90 },
  cable: { label: 'Koleje liniowe', order: 100 },
  gondola: { label: 'Gondola', order: 110 },
  funicular: { label: 'Funikular', order: 120 },
  monorail: { label: 'Monorail', order: 130 }
};
// --- END: Canonical route type collector

// ═══════════════════════════════════════════════════════════════
// 2. STATE MANAGEMENT
// ═══════════════════════════════════════════════════════════════

// Throttle render() during parsing to avoid excessive DOM updates
let lastRenderTime = 0;
const RENDER_THROTTLE_MS = 200; // Max 5 FPS

let state = {
  gtfsData: null,
  selectedRoute: null,
  loading: false,
  loadingStep: '',
  loadingProgress: 0,
  loadingProgressPercent: 0,
  error: '',
  selectedDate: '',
  availableDates: [],
  selectedDirection: '0',
  selectedVariant: 1,
  mapLoaded: false,
  showAllTrips: false,
  threshold: 10,
  currentWorker: null,
  // UI: group mode for routes list - 'route_id' or 'service_type'
  routeGroupMode: 'service_type',
  routesOptionsOpen: false,
  routesOptionsListenerAttached: false,
  // custom route type map can be injected/extended
  customRouteTypeMap: {},

  // NOWE:
  selectedRouteGroup: null,   // obecna logiczna grupa linii (dla listy linii)
  routeProfiles: {},          // profile tras (graf/core) per logical group + direction
  showStopsView: false,       // tryb „przystanki" vs „linie"
  routesListScrollPosition: 0, // scroll position for ROUTES_LIST view

  selectedStop: null,
  stopViewFilteredRoutes: [],
  
  // Stops list view state
  expandedStopGroup: null,
  stopsListMapState: null,
  stopsListSearchQuery: '',
  
  // FAZA 1.5: Pagination state
  stopsListPage: 1,
  stopsListPageSize: 50,
  
  // FAZA 2.1: Virtual list state
  virtualListStartIndex: 0,
  virtualListItemHeight: 68, // px - wysokość stop-group

  // Map layers for stop detail view
  stopDetailMapLayers: {},
  stopDetailMapInitialized: false,
  stopDetailMapInstance: null,
  stopDetailDepartures: [], // All departures for current stop

  // Cached timetable data for modal
  currentTimetableData: {
    allTrips: [],           // wszystkie trips (włącznie z ukrytymi)
    stopDepartures: {}      // mapa: stop_id -> lista odjazdów z trip_id i czasem
  },

  // Canonical master lists: stable row order per route/group + direction
  // Structure: canonicalMasterLists[key][direction] = { rows: [...], nodeTypeMap: {...} }
  // Rows are built from ALL trips (no date filter) and never reordered.
  // Only visibility is filtered at render time.
  canonicalMasterLists: {},

  // Column order cache: trips order per (key, dir, date, showAllTrips)
  // Structure: columnOrderCache[cacheKey] = [trip_id, ...]
  columnOrderCache: {}
};

let stopsSearchIndex = null;
let cachedGroupsArray = null;
let lastStopsDataHash = null;
let stationNameToIdCache = null;

// ═══════════════════════════════════════════════════════════════
// 3. UTILITY FUNCTIONS
// ═══════════════════════════════════════════════════════════════
//
// DATA PROCESSING PIPELINE OVERVIEW:
// ══════════════════════════════════
// 
// The GTFS data flows through several processing stages:
//
// 1. PARSE (CSV → Raw Objects)
//    - ZIP extraction & CSV parsing
//    - Worker-based parallel parsing for performance
//    - Produces raw JavaScript objects
//
// 2. NORMALIZE (Raw → Standardized)
//    - normalizeKey: CSV headers → GTFS standard field names
//    - normalizeRecord: Clean values (trim, remove quotes, handle nulls)
//    - Output: Clean GTFS-compliant records
//
// 3. INDEX (Records → Lookup Tables)
//    - Build indexes: stopTimesIndex, stopsIndex, shapesIndex, etc.
//    - Group related data for fast lookup
//    - Output: Queryable data structures
//
// 4. ENRICH (Add Computed Fields)
//    - enrichTripsWithDirectionId: Generate missing direction_id
//    - Shape simplification: Reduce coordinate density
//    - Route pattern analysis: Build canonical trip patterns
//    - Output: Enhanced domain model
//
// 5. CACHE (Persist Processed Data)
//    - cacheShapes: Store simplified shapes in localStorage
//    - Compression: Delta encoding + base36
//    - TTL: 30 days
//    - Output: Faster subsequent loads
//
// 6. RENDER (Display in UI)
//    - Map visualization (Leaflet)
//    - Timetable generation
//    - escapeHtml: Sanitize for safe HTML rendering
//    - Output: Interactive web interface
//
// FUNCTION PURITY:
// ────────────────
// @pure      = No side effects, same input → same output (can be memoized)
// @impure    = Has side effects (DOM updates, localStorage, mutations)
// @cached    = Results are memoized internally
// @presentation = UI-specific logic (not domain logic)
//
// MODULARITY:
// ───────────
// Functions are organized by concern:
// - 3.1: Data Normalization (CSV/GTFS cleaning)
// - 3.2: Time/Date (GTFS temporal logic)
// - 3.3: Geometry/Geography (WGS84 calculations)
// - 3.4: Cache/Serialization (localStorage persistence)
// - 3.5: Data Quality (Heuristics for feed quality)
// - 3.6: Direction Enrichment (direction_id generation)
//
// ═══════════════════════════════════════════════════════════════

// === DOM HELPERS ===
const $ = (id) => document.getElementById(id);
const $$ = (selector, root = document) => Array.from(root.querySelectorAll(selector));

// FIX #6: Debounce function for performance optimization
function debounce(func, wait) {
  let timeout;
  return function executedFunction(...args) {
    const later = () => {
      clearTimeout(timeout);
      func(...args);
    };
    clearTimeout(timeout);
    timeout = setTimeout(later, wait);
  };
}

// ═══════════════════════════════════════════════════════════════
// 3.1. DATA NORMALIZATION MODULE
// ═══════════════════════════════════════════════════════════════
// Pipeline: CSV/GTFS → normalized keys/values → domain model
//
// Questions addressed:
// - normalizeKey is deterministic and globally cacheable (keyCache)
// - normalizeRecord handles CSV-level normalization (quotes, whitespace)
// - escapeHtml is UI-layer sanitization (separate concern)
// - KEY_ALIAS provides GTFS field name standardization
// - Future: Could support per-feed alias injection via config
// ═══════════════════════════════════════════════════════════════

    /**
     * Escape HTML special characters for safe rendering
     * @pure UI sanitization layer - separate from data normalization
     * @param {string} s - String to escape
     * @returns {string} HTML-safe string
     */
    function escapeHtml(s) {
      if (s === null || s === undefined) return '';
      return String(s).replace(/[&<>"']/g, function(m) { return ({ '&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;' })[m]; });
    }

    // Memoization cache for normalizeKey (called millions of times)
    const keyCache = new Map();

    /**
     * Normalize a CSV header key to standard GTFS field name
     * @pure Deterministic - same input always produces same output
     * @cached Results are memoized in keyCache for performance
     * @param {string} k - Raw CSV header key
     * @returns {string} Normalized GTFS field name
     */
    function normalizeKey(k) {
      if (k === null || k === undefined) return k;
      
      // Check cache first
      if (keyCache.has(k)) return keyCache.get(k);
      
      let key = String(k).replace(/^\uFEFF/,'').trim().toLowerCase();
      const normalized = KEY_ALIAS[key] || key.replace(/\s+/g,'_');
      
      keyCache.set(k, normalized);
      return normalized;
    }

    /**
     * Normalize a complete CSV record to standard GTFS format
     * Handles: BOM removal, whitespace trimming, quote stripping
     * Pipeline stage: Raw CSV → Normalized GTFS record
     * @param {Object} rec - Raw CSV record with original keys
     * @returns {Object} Normalized record with GTFS-standard keys and cleaned values
     */
    function normalizeRecord(rec) {
      const out = {};
      Object.keys(rec).forEach(origKey => {
        const norm = normalizeKey(origKey);
        let val = rec[origKey];
        if (val === null || val === undefined) val = '';
        val = String(val).replace(/^"|"$/g,'').trim();
        out[norm] = val;
      });
      return out;
    }

// ═══════════════════════════════════════════════════════════════
// 3.2. TIME AND DATE MODULE (GTFS-specific)
// ═══════════════════════════════════════════════════════════════
// Internal representation: Time is ALWAYS stored as minutes since midnight
// This allows for GTFS times >24h (e.g., "25:30:00" for late-night service)
//
// Questions addressed:
// - Internal time format: minutes since midnight (0-based, can exceed 1440)
// - HH:MM:SS >24h is domain logic (GTFS spec allows it for service after midnight)
// - formatTime handles presentation layer (wraps at 24h for display)
// - GTFS dates are always in local timezone (YYYYMMDD format, no TZ info)
// - Date parsing/formatting is bidirectional (GTFS ↔ Date object)
// ═══════════════════════════════════════════════════════════════

    /**
     * Convert GTFS time string to minutes since midnight
     * @pure Domain layer conversion
     * @param {string} timeStr - GTFS time format "HH:MM:SS" (can be >24h)
     * @returns {number} Minutes since midnight (can exceed 1440 for late-night service)
     */
    function timeToMinutes(timeStr) {
      if (!timeStr) return 0;
      const parts = timeStr.split(':');
      const h = parseInt(parts[0] || '0', 10);
      const m = parseInt(parts[1] || '0', 10);
      return h * 60 + m;
    }

    /**
     * Convert minutes since midnight back to GTFS time format
     * @pure Inverse of timeToMinutes
     * @param {number} minutes - Minutes since midnight
     * @returns {string} GTFS time format "HH:MM:SS" (preserves >24h values)
     */
    function minutesToTime(minutes) {
      if (!minutes && minutes !== 0) return '';
      const h = Math.floor(minutes / 60);
      const m = minutes % 60;
      const s = 0;
      return `${String(h).padStart(2, '0')}:${String(m).padStart(2, '0')}:${String(s).padStart(2, '0')}`;
    }

    /**
     * Format time for display (presentation layer)
     * Wraps times ≥24h to 0-23h range for user-friendly display
     * @presentation Modifies times for UI display only
     * @param {string} time - GTFS time string
     * @returns {string} Display time in HH:MM format (wrapped to 24h)
     */
    function formatTime(time) {
      if (!time) return '<';
      const str = String(time);
      const parts = str.split(':');
      let hours = parseInt(parts[0]||'0',10);
      const minutes = parts[1]||'00';
      if (hours >= 24) hours = hours - 24;
      return `${String(hours).padStart(2,'0')}:${String(minutes).padStart(2,'0')}`;
    }

    /**
     * Parse GTFS date string (YYYYMMDD) to Date object
     * @pure Assumes local timezone (GTFS spec does not include timezone info)
     * @param {string} dateStr - GTFS date format "YYYYMMDD"
     * @returns {Date|null} JavaScript Date object in local timezone, or null if invalid
     */
    function parseGTFSDate(dateStr) {
      if(!dateStr || dateStr.length!==8) return null;
      return new Date(parseInt(dateStr.substring(0,4)), parseInt(dateStr.substring(4,6)) - 1, parseInt(dateStr.substring(6,8)));
    }

    /**
     * Format Date object to GTFS date string
     * @pure Inverse of parseGTFSDate
     * @param {Date} date - JavaScript Date object
     * @returns {string} GTFS date format "YYYYMMDD"
     */
    function formatDateToGTFS(date) {
      return date.getFullYear() + String(date.getMonth()+1).padStart(2,'0') + String(date.getDate()).padStart(2,'0');
    }

// ═══════════════════════════════════════════════════════════════
// 3.3. GEOMETRY AND GEOGRAPHY MODULE
// ═══════════════════════════════════════════════════════════════
// Coordinate system: WGS84 (latitude/longitude in decimal degrees)
// All geographic calculations assume WGS84 datum (implicit assumption)
//
// Questions addressed:
// - Coordinate system: WGS84 everywhere (GTFS standard)
// - Distance tolerance: 100m hardcoded for stop-shape matching (heuristic)
// - Shape simplification: Part of parsing/caching, not rendering
// - Simplification tolerance: 0.0001° (~11m) is configurable via parameter
// - Coverage calculation: Heuristic for quality assessment, not strict validation
// - These functions are GTFS-agnostic and could be reused for other geo apps
// ═══════════════════════════════════════════════════════════════

    /**
     * Simplify polyline using Douglas-Peucker algorithm
     * Used during shape parsing/caching to reduce data size
     * @pure Algorithm operates on coordinate arrays
     * @param {Array<[number, number]>} points - Array of [lat, lon] coordinates
     * @param {number} tolerance - Simplification tolerance in degrees (default: 0.0001 ≈ 11m)
     * @returns {Array<[number, number]>} Simplified coordinate array
     */
    function simplifyDouglasPeucker(points, tolerance = 0.0001) {
      if (!points || points.length <= 2) return points;
      
      // Calculate perpendicular distance from point to line segment
      function perpendicularDistance(point, lineStart, lineEnd) {
        const [x, y] = point;
        const [x1, y1] = lineStart;
        const [x2, y2] = lineEnd;
        
        const dx = x2 - x1;
        const dy = y2 - y1;
        
        if (dx === 0 && dy === 0) {
          return Math.sqrt((x - x1) ** 2 + (y - y1) ** 2);
        }
        
        const numerator = Math.abs(dy * x - dx * y + x2 * y1 - y2 * x1);
        const denominator = Math.sqrt(dx ** 2 + dy ** 2);
        
        return numerator / denominator;
      }
      
      // Recursive simplification
      function simplifyRecursive(points, tolerance, startIdx, endIdx) {
        let maxDistance = 0;
        let maxIndex = 0;
        
        // Find point with maximum distance from line
        for (let i = startIdx + 1; i < endIdx; i++) {
          const distance = perpendicularDistance(
            points[i],
            points[startIdx],
            points[endIdx]
          );
          
          if (distance > maxDistance) {
            maxDistance = distance;
            maxIndex = i;
          }
        }
        
        // If max distance is greater than tolerance, recursively simplify
        if (maxDistance > tolerance) {
          const leftPart = simplifyRecursive(points, tolerance, startIdx, maxIndex);
          const rightPart = simplifyRecursive(points, tolerance, maxIndex, endIdx);
          
          // Combine results (remove duplicate point at junction)
          return leftPart.slice(0, -1).concat(rightPart);
        } else {
          // Return just endpoints
          return [points[startIdx], points[endIdx]];
        }
      }
      
      return simplifyRecursive(points, tolerance, 0, points.length - 1);
    }

/**
 * Calculate great-circle distance between two WGS84 coordinates using Haversine formula
 * @pure Geographic calculation - no side effects
 * @param {number} lat1 - Start latitude in decimal degrees
 * @param {number} lon1 - Start longitude in decimal degrees
 * @param {number} lat2 - End latitude in decimal degrees
 * @param {number} lon2 - End longitude in decimal degrees
 * @returns {number} Distance in meters
 */
function haversineDistance(lat1, lon1, lat2, lon2) {
  const R = 6371000; // Earth radius in meters
  const φ1 = lat1 * Math.PI / 180;
  const φ2 = lat2 * Math.PI / 180;
  const Δφ = (lat2 - lat1) * Math.PI / 180;
  const Δλ = (lon2 - lon1) * Math.PI / 180;

  const a = Math.sin(Δφ / 2) * Math.sin(Δφ / 2) +
            Math.cos(φ1) * Math.cos(φ2) *
            Math.sin(Δλ / 2) * Math.sin(Δλ / 2);

  const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));

  return R * c;
}

/**
 * Calculate how well a shape covers a sequence of stops
 * Heuristic for data quality assessment - not a strict validation rule
 * @param {Array<Object>} stops - Array of stop objects with lat/lon
 * @param {Array<[number, number]>} shapePoints - Array of [lat, lon] shape coordinates
 * @returns {Object} Coverage analysis with percentage and nearby stops
 */
function calculateShapeCoverage(stops, shapePoints) {
  const MAX_DISTANCE_METERS = 100; // 100m tolerance (configurable heuristic)
  const nearbyStops = [];
  
  stops.forEach((stop, index) => {
    const stopLat = parseFloat(stop.lat || stop.stop_lat);
    const stopLon = parseFloat(stop.lon || stop.stop_lon);
    
    if (isNaN(stopLat) || isNaN(stopLon)) return;
    
    let minDistance = Infinity;
    let nearestShapeIndex = -1;
    
    shapePoints.forEach((shapePoint, shapeIndex) => {
      const distance = haversineDistance(
        stopLat, stopLon,
        shapePoint[0], shapePoint[1]
      );
      
      if (distance < minDistance) {
        minDistance = distance;
        nearestShapeIndex = shapeIndex;
      }
    });
    
    if (minDistance < MAX_DISTANCE_METERS) {
      nearbyStops.push({
        stopIndex: index,
        shapeIndex: nearestShapeIndex,
        distance: minDistance
      });
    }
  });
  
  return {
    percentage: nearbyStops.length / stops.length,
    nearbyStops: nearbyStops
  };
}

/**
 * Fill gaps in shape data by connecting stops with shape segments or straight lines
 * @param {Array<Object>} stops - Array of stop objects
 * @param {Array<[number, number]>} shapePoints - Shape coordinate array  
 * @param {Array<Object>} nearbyStops - Stops matched to shape points
 * @returns {Array<[number, number]>} Complete route geometry
 */
function fillShapeGaps(stops, shapePoints, nearbyStops) {
  const result = [];
  
  for (let i = 0; i < stops.length - 1; i++) {
    const currentStop = stops[i];
    const nextStop = stops[i + 1];
    
    const currentNearby = nearbyStops.find(n => n.stopIndex === i);
    const nextNearby = nearbyStops.find(n => n.stopIndex === i + 1);
    
    // Case 1: Both stops covered by shape - use shape segment
    if (currentNearby && nextNearby) {
      const startIdx = currentNearby.shapeIndex;
      const endIdx = nextNearby.shapeIndex;
      
      if (endIdx > startIdx) {
        const segment = shapePoints.slice(startIdx, endIdx + 1);
        result.push(...segment);
      } else {
        // Shape goes backwards - use straight line
        result.push(
          [parseFloat(currentStop.lat || currentStop.stop_lat), parseFloat(currentStop.lon || currentStop.stop_lon)],
          [parseFloat(nextStop.lat || nextStop.stop_lat), parseFloat(nextStop.lon || nextStop.stop_lon)]
        );
      }
    }
    // Case 2: Gap in shape - fill with straight line
    else {
      if (i === 0 || result.length === 0) {
        result.push([parseFloat(currentStop.lat || currentStop.stop_lat), parseFloat(currentStop.lon || currentStop.stop_lon)]);
      }
      result.push([parseFloat(nextStop.lat || nextStop.stop_lat), parseFloat(nextStop.lon || nextStop.stop_lon)]);
    }
  }
  
  return result;
}

// ═══════════════════════════════════════════════════════════════
// 3.4. CACHE AND SERIALIZATION MODULE
// ═══════════════════════════════════════════════════════════════
// Cache backend: localStorage (browser-based persistent storage)
// Cache strategy: Content-addressable via hash, with TTL and versioning
//
// Questions addressed:
// - Cache backend: localStorage (suitable for client-side caching)
// - Hash collision resistance: Simple hash (good enough for cache keys, not cryptographic)
// - TTL: 30 days (arbitrary but reasonable for transit data staleness)
// - Versioning: Explicit version field (v2 = compressed format)
// - Cache scope: Currently shapes only, but design is generic (could extend to routeProfiles)
// - Compression: Delta encoding + base36 (stable, lossy to 6 decimal places ≈ 0.11m precision)
// - Cleanup: Best-effort on QuotaExceededError (not deterministic)
// ═══════════════════════════════════════════════════════════════

    /**
     * Compress coordinate array using delta encoding and base36
     * Lossy compression: preserves 6 decimal places (≈0.11m precision)
     * @param {Array<[number, number]>} coords - Array of [lat, lon] coordinates
     * @returns {string} Compressed string representation
     */
    function compressCoordinates(coords) {
      if (!coords || coords.length === 0) return '';
      
      // Delta encode: store first point, then differences
      const deltas = [];
      let prevLat = 0, prevLon = 0;
      
      for (const [lat, lon] of coords) {
        // Multiply by 1e6 to preserve 6 decimal places, then round to integer
        const latInt = Math.round(lat * 1e6);
        const lonInt = Math.round(lon * 1e6);
        
        deltas.push(latInt - prevLat);
        deltas.push(lonInt - prevLon);
        
        prevLat = latInt;
        prevLon = lonInt;
      }
      
      // Convert to base64-like compact string
      return deltas.map(d => d.toString(36)).join(',');
    }

    function decompressCoordinates(compressed) {
      if (!compressed) return [];
      
      const deltas = compressed.split(',').map(s => parseInt(s, 36));
      const coords = [];
      let lat = 0, lon = 0;
      
      for (let i = 0; i < deltas.length; i += 2) {
        lat += deltas[i];
        lon += deltas[i + 1];
        
        // Divide by 1e6 to restore decimal coordinates
        coords.push([lat / 1e6, lon / 1e6]);
      }
      
      return coords;
    }

    function hashShapesData(shapesIndex) {
      const keys = Object.keys(shapesIndex).sort();
      const sample = keys.slice(0, 10).join(',') + keys.length;
      let hash = 0;
      for (let i = 0; i < sample.length; i++) {
        const char = sample.charCodeAt(i);
        hash = ((hash << 5) - hash) + char;
        hash = hash & hash;
      }
      return 'shapes_' + Math.abs(hash).toString(36);
    }

    function cacheShapes(shapesIndex, simplified) {
      try {
        const cacheKey = hashShapesData(shapesIndex);
        
        // Compress each shape's coordinates
        const compressed = {};
        Object.keys(simplified).forEach(shapeId => {
          compressed[shapeId] = compressCoordinates(simplified[shapeId]);
        });
        
        const cacheData = {
          version: 2, // version 2 uses compression
          timestamp: Date.now(),
          shapes: compressed
        };
        
        const jsonStr = JSON.stringify(cacheData);
        const originalSize = jsonStr.length;
        
        localStorage.setItem(cacheKey, jsonStr);
      } catch (e) {
        // If storage quota exceeded, try to clear old caches
        if (e.name === 'QuotaExceededError') {
          try {
            // Remove old shape caches
            for (let i = 0; i < localStorage.length; i++) {
              const key = localStorage.key(i);
              if (key && key.startsWith('shapes_')) {
                localStorage.removeItem(key);
              }
            }
          } catch (e2) {
            // Ignore cache cleanup errors - they don't affect core functionality
          }
        }
      }
    }

    function loadCachedShapes(shapesIndex) {
      try {
        const cacheKey = hashShapesData(shapesIndex);
        const cached = localStorage.getItem(cacheKey);
        if (!cached) return null;
        
        const data = JSON.parse(cached);
        
        // Check if cache is not too old (30 days)
        const age = Date.now() - data.timestamp;
        if (age > 30 * 24 * 60 * 60 * 1000) {
          localStorage.removeItem(cacheKey);
          return null;
        }
        
        // Decompress coordinates
        const shapes = {};
        Object.keys(data.shapes).forEach(shapeId => {
          if (data.version === 2) {
            // Version 2 uses compression
            shapes[shapeId] = decompressCoordinates(data.shapes[shapeId]);
          } else {
            // Version 1 or unversioned - direct coordinates
            shapes[shapeId] = data.shapes[shapeId];
          }
        });
        
        return shapes;
      } catch (e) {
        return null;
      }
    }

    function simplifyShapes(shapesIndex, tolerance = 0.0001) {
      const simplified = {};
      let totalOriginal = 0;
      let totalSimplified = 0;
      
      Object.keys(shapesIndex).forEach(shapeId => {
        const points = shapesIndex[shapeId];
        totalOriginal += points.length;
        
        if (points.length <= 2) {
          simplified[shapeId] = points;
          totalSimplified += points.length;
        } else {
          const simplifiedPoints = simplifyDouglasPeucker(points, tolerance);
          simplified[shapeId] = simplifiedPoints;
          totalSimplified += simplifiedPoints.length;
        }
      });
      
      const reduction = totalOriginal > 0 
        ? Math.round((1 - totalSimplified / totalOriginal) * 100) 
        : 0;
      
      return simplified;
    }

// ═══════════════════════════════════════════════════════════════
// 3.5. DATA QUALITY HEURISTICS MODULE
// ═══════════════════════════════════════════════════════════════
// Quality scoring and validation for GTFS feed data
//
// Questions addressed:
// - These heuristics are GTFS-specific (rely on GTFS naming conventions)
// - "Garbage label" is domain logic (determines if route name is usable)
// - short_name vs long_name: implicit scoring via looksLikeGarbageLabel
// - Heuristics are currently hardcoded but could be made configurable
// - These rules encode domain knowledge about transit data quality
// ═══════════════════════════════════════════════════════════════

/**
 * Find the most common string in an array (consensus-based data cleaning)
 * @pure Frequency counting algorithm
 * @param {Array<string>} arr - Array of strings to analyze
 * @returns {string|null} Most frequent non-empty string, or null if none found
 */
function mostCommonString(arr) {
  const counts = Object.create(null);
  for (const s of arr) {
    if (!s) continue;
    const t = String(s).trim();
    if (!t) continue;
    counts[t] = (counts[t] || 0) + 1;
  }
  let best = null, bestCount = 0;
  Object.keys(counts).forEach(k => { if (counts[k] > bestCount) { best = k; bestCount = counts[k]; }});
  return best;
}

/**
 * Heuristic to detect uninformative route labels
 * Rejects: empty, too short, numeric-only (unless differs from shortName)
 * Domain knowledge: Many feeds use numeric codes as long_name, which is not useful
 * @param {string} s - Label to check
 * @param {string} shortName - Route short_name for comparison
 * @returns {boolean} True if label appears to be garbage/uninformative
 */
function looksLikeGarbageLabel(s, shortName) {
  if (!s) return true;
  const t = String(s).trim();
  if (t.length < 2) return true;
  if (/^[0-9\-\s]+$/.test(t)) {
    if (!shortName) return true;
    if (t.replace(/\s+/g,'') === String(shortName).replace(/\s+/g,'')) return true;
  }
  return false;
}

// ═══════════════════════════════════════════════════════════════
// 3.6. DIRECTION_ID ENRICHMENT MODULE
// ═══════════════════════════════════════════════════════════════
// Pipeline for generating direction_id when missing from GTFS feed
// Decision pipeline: Group by route → Find patterns → Score sequences → Assign directions
//
// Questions addressed:
// - direction_id is treated as binary classification (0/1) but handles edge cases
// - Routes with >2 directions: Uses heuristics (longest trip as reference pattern)
// - Circular routes: Detected via first==last stop, handled specially
// - Subsequence matching: Ignores branch-specific stops, focuses on common trunk
// - Bearing as tiebreaker: Used when sequence scores are identical
// - Incomplete stopsIndex: Gracefully degrades (trips without stops get direction_id=0)
// - Determinism: Stable within a feed, but may vary between feeds with different data
// - This is a decision pipeline, not a single function (multi-stage enrichment)
// ═══════════════════════════════════════════════════════════════

/**
 * Calculate bearing (azimuth) between two geographic points
 * Reused from geometry module for direction detection
 * @pure Geographic calculation
 * @param {number} lat1 - Start latitude
 * @param {number} lon1 - Start longitude
 * @param {number} lat2 - End latitude
 * @param {number} lon2 - End longitude
 * @returns {number} Bearing in degrees (0-360)
 */
const TO_RAD = Math.PI / 180;
const TO_DEG = 180 / Math.PI;
function calculateBearing(lat1, lon1, lat2, lon2) {
  const dLon = (lon2 - lon1) * TO_RAD;
  const y = Math.sin(dLon) * Math.cos(lat2 * TO_RAD);
  const x = Math.cos(lat1 * TO_RAD) * Math.sin(lat2 * TO_RAD) -
            Math.sin(lat1 * TO_RAD) * Math.cos(lat2 * TO_RAD) * Math.cos(dLon);
  
  let bearing = Math.atan2(y, x) * TO_DEG;
  return (bearing + 360) % 360; // Normalize to 0-360
}

/**
 * Score how well a trip sequence matches a reference pattern
 * Uses subsequence matching: ignores branch-specific stops, matches trunk stops
 * @pure Longest common subsequence scoring
 * @param {Array<string>} tripSeq - Trip stop sequence to score
 * @param {Array<string>} pattern - Reference pattern to match against
 * @returns {number} Score from 0 to 1 representing the ratio of matched stops
 */
function tripSequenceScore(tripSeq, pattern) {
  // Count how many stops from tripSeq appear in correct order in pattern
  // Only consider stops that exist in the pattern (ignore branch-specific stops)
  const patternSet = new Set(pattern);
  const relevantStops = tripSeq.filter(stop => patternSet.has(stop));
  
  if (relevantStops.length === 0) return 0;
  
  let matchCount = 0;
  let idx = 0;
  
  for (let i = 0; i < relevantStops.length; i++) {
    const val = relevantStops[i];
    while (idx < pattern.length && pattern[idx] !== val) {
      idx++;
    }
    if (idx < pattern.length) {
      matchCount++;
      idx++;
    }
  }
  
  return matchCount / relevantStops.length;
}

/**
 * Get stop sequence for a trip
 * @param {string} tripId - Trip ID
 * @param {Object} stopTimesIndex - Index of stop times by trip_id
 * @returns {Array<string>} Array of stop_ids in sequence
 */
function getTripStopSequence(tripId, stopTimesIndex) {
  const stopTimes = stopTimesIndex[tripId];
  if (!stopTimes || stopTimes.length === 0) return [];
  return stopTimes.map(st => st.stop_id);
}

/**
 * Check if a route is circular (starts and ends at same stop)
 * @pure Simple check on stop sequence
 * @param {Array<string>} stopSequence - Array of stop_ids
 * @returns {boolean} True if circular
 */
function isCircularRoute(stopSequence) {
  if (!stopSequence || stopSequence.length < 2) return false;
  return stopSequence[0] === stopSequence[stopSequence.length - 1];
}

/**
 * Enrich trips with direction_id when missing from GTFS feed
 * 
 * Decision Pipeline:
 * 1. Group trips by route_id
 * 2. Build stop sequences for each trip
 * 3. Check for circular routes (all get direction_id=0)
 * 4. Find longest trip as reference pattern
 * 5. Create forward and reverse patterns
 * 6. Score each trip against both patterns (subsequence matching)
 * 7. Use bearing as tiebreaker when scores are close
 * 
 * Edge cases handled:
 * - Missing stop sequences: Assign direction_id=0
 * - Circular routes: All trips get direction_id=0 (no meaningful direction)
 * - Routes with branches: Subsequence matching ignores branch-specific stops
 * - Close scores: Use geographic bearing as tiebreaker
 * - Missing geo data: Fallback to sequence score only
 * 
 * @impure Mutates trip objects to add direction_id field
 * @param {Array<Object>} trips - Array of trip objects
 * @param {Object} stopTimesIndex - Index of stop times by trip_id
 * @param {Object} stopsIndex - Index of stops by stop_id
 */
function enrichTripsWithDirectionId(trips, stopTimesIndex, stopsIndex) {
  // Group trips by route_id
  const tripsByRoute = {};
  
  for (const trip of trips) {
    if (!trip || !trip.trip_id) continue;
    
    const routeId = trip.route_id || 'unknown';
    if (!tripsByRoute[routeId]) {
      tripsByRoute[routeId] = [];
    }
    tripsByRoute[routeId].push(trip);
  }
  
  // Process each route
  for (const routeId in tripsByRoute) {
    const routeTrips = tripsByRoute[routeId];
    
    // Filter trips that need direction_id
    const tripsToProcess = routeTrips.filter(t => 
      !t.direction_id || t.direction_id === ''
    );
    
    if (tripsToProcess.length === 0) continue;
    
    // STEP 1: Build stop sequences
    const tripPatterns = tripsToProcess.map(trip => ({
      tripId: trip.trip_id,
      trip: trip,
      sequence: getTripStopSequence(trip.trip_id, stopTimesIndex)
    }));
    
    // Filter out trips without stop sequences
    const validPatterns = tripPatterns.filter(p => p.sequence.length > 0);
    
    if (validPatterns.length === 0) {
      // No valid patterns, assign all to direction 0
      tripsToProcess.forEach(trip => trip.direction_id = '0');
      continue;
    }
    
    // STEP 2: Check for circular routes
    const isCircular = validPatterns.every(p => isCircularRoute(p.sequence));
    if (isCircular) {
      // All trips are circular, assign direction 0
      tripsToProcess.forEach(trip => trip.direction_id = '0');
      continue;
    }
    
    // STEP 3: Reward-only subsequence matching with bearing tiebreaker
    // Find the longest trip to use as the reference pattern
    let refPattern = null;
    let maxLen = 0;
    
    for (const pattern of validPatterns) {
      if (pattern.sequence.length > maxLen) {
        maxLen = pattern.sequence.length;
        refPattern = pattern;
      }
    }
    
    if (!refPattern || refPattern.sequence.length === 0) {
      // No valid reference pattern, assign all to direction 0
      tripsToProcess.forEach(trip => trip.direction_id = '0');
      continue;
    }
    
    // Create forward and reverse patterns
    const patternFwd = refPattern.sequence;
    const patternRev = [...patternFwd].reverse();
    
    // Calculate reference bearing (from first to last stop of pattern)
    let refBearing = null;
    if (stopsIndex && patternFwd.length >= 2) {
      const firstStop = stopsIndex[patternFwd[0]];
      const lastStop = stopsIndex[patternFwd[patternFwd.length - 1]];
      
      if (firstStop && lastStop) {
        const lat1 = parseFloat(firstStop.stop_lat);
        const lon1 = parseFloat(firstStop.stop_lon);
        const lat2 = parseFloat(lastStop.stop_lat);
        const lon2 = parseFloat(lastStop.stop_lon);
        
        if (!isNaN(lat1) && !isNaN(lon1) && !isNaN(lat2) && !isNaN(lon2)) {
          refBearing = calculateBearing(lat1, lon1, lat2, lon2);
        }
      }
    }
    
    // Score each trip against both patterns
    tripsToProcess.forEach(trip => {
      const seq = getTripStopSequence(trip.trip_id, stopTimesIndex);
      
      if (!seq || seq.length === 0) {
        trip.direction_id = '0';
        return;
      }
      
      const scoreFwd = tripSequenceScore(seq, patternFwd);
      const scoreRev = tripSequenceScore(seq, patternRev);
      
      // If scores are clearly different, use the higher score
      if (scoreFwd > scoreRev + 0.1) {
        trip.direction_id = '0';
      } else if (scoreRev > scoreFwd + 0.1) {
        trip.direction_id = '1';
      } else {
        // Scores are equal or very close - use bearing as tiebreaker
        if (refBearing !== null && stopsIndex && seq.length >= 2) {
          const firstStop = stopsIndex[seq[0]];
          const lastStop = stopsIndex[seq[seq.length - 1]];
          
          if (firstStop && lastStop) {
            const lat1 = parseFloat(firstStop.stop_lat);
            const lon1 = parseFloat(firstStop.stop_lon);
            const lat2 = parseFloat(lastStop.stop_lat);
            const lon2 = parseFloat(lastStop.stop_lon);
            
            if (!isNaN(lat1) && !isNaN(lon1) && !isNaN(lat2) && !isNaN(lon2)) {
              const tripBearing = calculateBearing(lat1, lon1, lat2, lon2);
              
              // Calculate bearing difference (accounting for wrap-around)
              let diff = Math.abs(tripBearing - refBearing);
              if (diff > 180) diff = 360 - diff;
              
              // If bearings are similar (within 90°), same direction
              // If bearings are opposite (>90°), reverse direction
              trip.direction_id = diff < 90 ? '0' : '1';
            } else {
              trip.direction_id = '0'; // Fallback
            }
          } else {
            trip.direction_id = '0'; // Fallback
          }
        } else {
          trip.direction_id = '0'; // Fallback for equal scores without bearing data
        }
      }
    });
  }
}

// ═══════════════════════════════════════════════════════════════
// 4. DATA PARSING & LOADING
// ═══════════════════════════════════════════════════════════════
function parseCSV(text) {
  const lines = text.split(/\r?\n/);
  if (lines.length === 0) return [];
  
  // Helper:  parse CSV line with proper quote handling
  function parseCSVLine(line) {
    const result = [];
    let current = '';
    let inQuotes = false;
    
    for (let i = 0; i < line.length; i++) {
      const char = line[i];
      
      if (char === '"') {
        if (inQuotes && line[i + 1] === '"') {
          // Escaped quote ("")
          current += '"';
          i++; // Skip next quote
        } else {
          // Toggle quote mode
          inQuotes = !inQuotes;
        }
      } else if (char === ',' && !inQuotes) {
        // Field separator (outside quotes)
        result.push(current);
        current = '';
      } else {
        current += char;
      }
    }
    
    // Add last field
    result.push(current);
    
    return result;
  }
  
  // Parse header
  const headerLine = lines[0]. replace(/^\uFEFF/, '');
  const headers = parseCSVLine(headerLine).map(h => h.trim());
  
  const result = [];
  
  // Parse data rows
  for (let i = 1; i < lines.length; i++) {
    const line = lines[i].trim();
    if (!line) continue;
    
    const values = parseCSVLine(line);
    const row = {};
    
    headers. forEach((header, idx) => {
      let value = values[idx] || '';
      value = value.trim();
      row[header] = value;
    });
    
    result.push(normalizeRecord(row));
  }
  
  return result;
}

function parseStopTimesStreamWithWorker(zipFileEntry, onProgress) {
  return new Promise(async (resolve, reject) => {
    try {
      const arrayBuffer = await zipFileEntry. async('arraybuffer');
      const decoder = new TextDecoder('utf-8');
      
      let buffer = '';
      let lineCount = 0;
      let headers = null;
      const stopTimesIndex = Object.create(null);
      
      const PROGRESS_UPDATE_INTERVAL = 100000;  // ← Increased from 10k
      const ESTIMATED_LINES_FOR_PROGRESS = 100000;
      const CHUNK_SIZE = 1024 * 1024;
      
      // ═══ REMOVED smartSplit - use native split! ═══
      
      // Fast column getter - minimal operations
      const getCol = (cols, idx) => {
        if (idx === -1 || idx >= cols.length) return '';
        let val = cols[idx];
        if (!val) return '';
        
        // Remove quotes in-place
        if (val[0] === '"' && val[val.length-1] === '"') {
          val = val.substring(1, val.length - 1);
        }
        
        // Trim only if needed (check first/last char)
        if (val[0] === ' ' || val[val.length-1] === ' ') {
          return val.trim();
        }
        
        return val;
      };
      
      const processLine = (line) => {
        if (!line. trim()) return;
        
        if (!headers) {
  const rawHeaders = line. split(',').map(h => h.replace(/^"|"$/g, '').trim());  // ← Dodaj .map()
  headers = {
    tripIdx: -1,
    stopIdx: -1,
            seqIdx: -1,
            arrIdx: -1,
            depIdx: -1,
            pickupIdx: -1,
            dropoffIdx: -1
          };
          
rawHeaders.forEach((h, i) => {
    const normalized = normalizeKey(h);
            if (normalized === 'trip_id') headers.tripIdx = i;
            else if (normalized === 'stop_id') headers.stopIdx = i;
            else if (normalized === 'stop_sequence') headers.seqIdx = i;
            else if (normalized === 'arrival_time') headers.arrIdx = i;
            else if (normalized === 'departure_time') headers.depIdx = i;
            else if (normalized === 'pickup_type') headers.pickupIdx = i;
            else if (normalized === 'drop_off_type') headers.dropoffIdx = i;
          });
          
          if (headers.tripIdx === -1 || headers.stopIdx === -1) {
            throw new Error('Brakuje wymaganych kolumn w stop_times.txt: trip_id lub stop_id');
          }
          return;
        }
        
        // ═══ NATIVE SPLIT - 100x faster than smartSplit! ═══
        const cols = line.split(',');
        
        if (cols.length <= Math.max(headers.tripIdx, headers. stopIdx)) return;
        
        const tripId = getCol(cols, headers.tripIdx);
        const stopId = getCol(cols, headers.stopIdx);
        
        if (!tripId || !stopId) return;
        
        if (!stopTimesIndex[tripId]) {
          stopTimesIndex[tripId] = [];
        }
        
        stopTimesIndex[tripId].push({
          stop_id: stopId,
          arrival_time: getCol(cols, headers.arrIdx),
          departure_time: getCol(cols, headers.depIdx),
          stop_sequence: parseInt(getCol(cols, headers.seqIdx) || '0', 10),
          pickup_type: getCol(cols, headers.pickupIdx) || '0',  // ← Removed String()
          drop_off_type: getCol(cols, headers.dropoffIdx) || '0'  // ← Removed String()
        });
        
        lineCount++;
        if (lineCount % PROGRESS_UPDATE_INTERVAL === 0) {  // ← Less frequent
          state.loadingProgress = lineCount;
          if (onProgress) {
            onProgress(lineCount, Math.min(99, Math.round(lineCount / ESTIMATED_LINES_FOR_PROGRESS * 100)));
          }
        }
      };
      
      // Process arrayBuffer in chunks (same as before)
      let offset = 0;
      while (offset < arrayBuffer.byteLength) {
        const chunkEnd = Math.min(offset + CHUNK_SIZE, arrayBuffer.byteLength);
        const chunk = new Uint8Array(arrayBuffer, offset, chunkEnd - offset);
        const isLastChunk = chunkEnd === arrayBuffer.byteLength;
        const text = decoder.decode(chunk, { stream: !isLastChunk });
        buffer += text;
        
        let newlineIndex;
        while ((newlineIndex = buffer.indexOf('\n')) !== -1) {
          const line = buffer.substring(0, newlineIndex);
          processLine(line);
          buffer = buffer.substring(newlineIndex + 1);
        }
        
        offset = chunkEnd;
      }
      
      if (buffer.trim()) processLine(buffer);
      
      // Sort (same as before)
      Object.keys(stopTimesIndex).forEach(tripId => {
        stopTimesIndex[tripId].sort((a, b) => a.stop_sequence - b.stop_sequence);
      });
      
      if (onProgress) onProgress(lineCount, 100);
      resolve(stopTimesIndex);
      
    } catch(err) {
      reject(err);
    }
  });
}

    function parseShapesWithWorker(zipFileEntry, onProgress) {
      return new Promise(async (resolve, reject) => {
        try {
          const text = await zipFileEntry.async('string');
          
          const workerCode = `
            function smartSplit(line) {
              if (!line.includes('"')) {
                return line.split(',');
              }
              
              const cols = [];
              let current = '';
              let inQuotes = false;
              
              for (let i = 0; i < line.length; i++) {
                const char = line[i];
                
                if (char === '"') {
                  if (i + 1 < line.length && line[i+1] === '"') {
                    current += '"';
                    i++;
                  } else {
                    inQuotes = !inQuotes;
                  }
                } else if (char === ',' && !inQuotes) {
                  cols.push(current);
                  current = '';
                } else {
                  current += char;
                }
              }
              cols.push(current);
              return cols;
            }
            
            self.onmessage = function(e) {
              const text = e.data.text;
              const lines = text.split(/\\r?\\n/);
              
              if (lines.length === 0) {
                self.postMessage({ type: 'done', shapesIndex: {} });
                return;
              }
              
              // Parse header
              const headerLine = lines[0];
              const rawHeaders = smartSplit(headerLine);
              const headers = rawHeaders.map(h => normalizeKey(h));
              
              const shapeIdIdx = headers.indexOf('shape_id');
              const latIdx = headers.indexOf('shape_pt_lat');
              const lonIdx = headers.indexOf('shape_pt_lon');
              const seqIdx = headers.indexOf('shape_pt_sequence');
              
              if (shapeIdIdx === -1 || latIdx === -1 || lonIdx === -1 || seqIdx === -1) {
                self.postMessage({ 
                  type: 'error', 
                  message: 'shapes.txt missing required fields' 
                });
                return;
              }
              
              const shapesData = {};
              let processedRows = 0;
              const totalRows = lines.length - 1;
              
              // Parse all rows
              for (let i = 1; i < lines.length; i++) {
                const line = lines[i].trim();
                if (!line) continue;
                
                const cols = smartSplit(line);
                const shapeId = cols[shapeIdIdx];
                const lat = parseFloat(cols[latIdx]);
                const lon = parseFloat(cols[lonIdx]);
                const seq = parseInt(cols[seqIdx] || '0', 10);
                
                if (!shapeId || isNaN(lat) || isNaN(lon)) continue;
                
                if (!shapesData[shapeId]) {
                  shapesData[shapeId] = [];
                }
                
                shapesData[shapeId].push({ lat, lon, seq });
                processedRows++;
                
                // Report progress every 10000 rows
                if (processedRows % 10000 === 0) {
                  const percent = Math.round((processedRows / totalRows) * 100);
                  self.postMessage({ 
                    type: 'progress', 
                    processed: processedRows,
                    total: totalRows,
                    percent 
                  });
                }
              }
              
              // Sort points by sequence for each shape
              const shapesIndex = {};
              Object.keys(shapesData).forEach(shapeId => {
                const points = shapesData[shapeId];
                points.sort((a, b) => a.seq - b.seq);
                shapesIndex[shapeId] = points.map(p => [p.lat, p.lon]);
              });
              
              self.postMessage({ 
                type: 'done', 
                shapesIndex,
                shapeCount: Object.keys(shapesIndex).length,
                pointCount: processedRows
              });
            };
          `;
          
          const blob = new Blob([workerCode], { type: 'application/javascript' });
          const workerUrl = URL.createObjectURL(blob);
          const worker = new Worker(workerUrl);
          state.currentWorker = worker;
          
          worker.onmessage = function(ev) {
            const msg = ev.data;
            
            if (msg.type === 'progress') {
              if (onProgress) {
                onProgress(msg.processed, msg.percent);
              }
            } else if (msg.type === 'done') {
              state.currentWorker = null;
              URL.revokeObjectURL(workerUrl);
              resolve(msg.shapesIndex);
            } else if (msg.type === 'error') {
              state.currentWorker = null;
              URL.revokeObjectURL(workerUrl);
              reject(new Error(msg.message));
            }
          };
          
          worker.onerror = function(ev) {
            state.currentWorker = null;
            URL.revokeObjectURL(workerUrl);
            reject(new Error(ev.message || 'Worker parse error'));
          };
          
          // Start parsing
          worker.postMessage({ text });
          
        } catch(err) {
          reject(err);
        }
      });
    }

    async function unzipWithFflate(file) {
      return new Promise((resolve, reject) => {
        const reader = new FileReader();
        
        reader.onload = function(e) {
          try {
            const arrayBuffer = e.target.result;
            const uint8Array = new Uint8Array(arrayBuffer);
            
            // Use fflate.unzip to decompress
            fflate.unzip(uint8Array, (err, unzipped) => {
              if (err) {
                reject(new Error('Failed to decompress ZIP: ' + err.message));
                return;
              }
              
              // Create JSZip-compatible structure
              const files = {};
              
              for (const [path, data] of Object.entries(unzipped)) {
                // Skip directories (they end with /)
                if (path.endsWith('/')) continue;
                
                files[path] = {
                  name: path,
                  _data: data,
                  async: function(type) {
                    return Promise.resolve().then(() => {
                      if (type === 'string') {
                        // Decode UTF-8 using TextDecoder
                        const decoder = new TextDecoder('utf-8');
                        return decoder.decode(this._data);
                      } else if (type === 'arraybuffer') {
                        // Return as ArrayBuffer
                        return this._data.buffer.slice(this._data.byteOffset, this._data.byteOffset + this._data.byteLength);
                      } else if (type === 'uint8array') {
                        // Return the Uint8Array directly
                        return this._data;
                      } else if (type === 'blob') {
                        // Create a Blob from the data
                        return new Blob([this._data]);
                      }
                      // For other types, return the raw Uint8Array
                      return this._data;
                    });
                  }
                };
              }
              
              resolve({ files });
            });
          } catch (err) {
            reject(new Error('Error reading ZIP file: ' + err.message));
          }
        };
        
        reader.onerror = function() {
          reject(new Error('Failed to read file'));
        };
        
        reader.readAsArrayBuffer(file);
      });
    }

    function findFile(filesObj, filename) {
      const lowerFilename = filename.toLowerCase();
      
      // Try exact match first
      if (filesObj[filename]) {
        return filesObj[filename];
      }
      
      // Try case-insensitive search
      for (const path in filesObj) {
        const lowerPath = path.toLowerCase();
        
        // Check if the path ends with the filename (handles subdirectories)
        if (lowerPath === lowerFilename || lowerPath.endsWith('/' + lowerFilename)) {
          return filesObj[path];
        }
      }
      
      return null;
    }

    async function handleFileUpload(e) {
      const file = e.target.files[0]; if (!file) return;
      const t0 = performance.now();
      state.loading = true; state.loadingStep = 'Odczytywanie archiwum GTFS...'; state.loadingProgress=0; state.loadingProgressPercent=0; state.error='';
      render();
      try {
        // Use fflate for fast ZIP decompression
        state.loadingStep = 'Rozpakowywanie ZIP (fflate)...'; render();
        const zip = await unzipWithFflate(file);
        state.loadingStep = 'Wyodrębnianie plików...'; render();
        
        const [routesFile, tripsFile, stopTimesFile, stopsFile, calendarFile, calendarDatesFile, agenciesFile, shapesFile] = 
          ['routes.txt', 'trips.txt', 'stop_times.txt', 'stops.txt', 'calendar.txt', 'calendar_dates.txt', 'agency.txt', 'shapes.txt']
          .map(filename => findFile(zip.files, filename));
        
        // Walidacja wymaganych plików
        if (!routesFile || !tripsFile || !stopTimesFile || !stopsFile) {
          throw new Error('Brakuje wymaganych plików GTFS (routes.txt, trips.txt, stop_times.txt, stops.txt)');
        }

// ==========================================
// PARALLEL LOADING & PARSING - małe pliki jednocześnie
// ==========================================
state.loadingStep = 'Wczytywanie i parsowanie plików (równolegle)...'; render();

const [routes, trips, stops, calendar, calendarDates, agencies] = await Promise.all([
  routesFile.async('string').then(text => parseCSV(text)),
  tripsFile.async('string').then(text => parseCSV(text)),
  stopsFile.async('string').then(text => parseCSV(text)),
  calendarFile ? calendarFile.async('string').then(text => parseCSV(text)) : Promise.resolve([]),
  calendarDatesFile ? calendarDatesFile.async('string').then(text => parseCSV(text)) : Promise.resolve([]),
  agenciesFile ? agenciesFile.async('string').then(text => parseCSV(text)) : Promise.resolve([])
]);
        state.loadingStep = 'Parsowanie stop_times (streaming)...'; render();
        const stopTimesIndex = await parseStopTimesStreamWithWorker(stopTimesFile, (rowsProcessed, percent) => {
          state.loadingStep = `Parsowanie stop_times: ${rowsProcessed.toLocaleString()} wierszy`;
          state.loadingProgressPercent = percent || state.loadingProgressPercent;
          render();
        });
        
        // Parse shapes.txt if available (optional)
        let shapesIndex = {};
        if (shapesFile) {
          state.loadingStep = 'Parsowanie shapes.txt (streaming)...'; render();
          try {
            const rawShapes = await parseShapesWithWorker(shapesFile, (rowsProcessed, percent) => {
              state.loadingStep = `Parsowanie shapes: ${rowsProcessed.toLocaleString()} punktów`;
              state.loadingProgressPercent = percent || state.loadingProgressPercent;
              render();
            });
            
            // Try to load from cache
            let simplifiedShapes = loadCachedShapes(rawShapes);
            
            if (!simplifiedShapes) {
              // Simplify and cache
              state.loadingStep = 'Upraszczanie tras (Douglas-Peucker)...'; render();
              simplifiedShapes = simplifyShapes(rawShapes, 0.0001);
              cacheShapes(rawShapes, simplifiedShapes);
            }
            
            shapesIndex = simplifiedShapes;
          } catch (err) {
            // Continue without shapes - they're optional
          }
        }
        
        state.loadingStep = 'Budowanie indeksów...'; render();
        const stopsIndex = {}; stops.forEach(s=>{ if (s && s.stop_id) stopsIndex[s.stop_id]=s; });
        
        // Generate missing direction_id values
        state.loadingStep = 'Generowanie brakujących direction_id...'; render();
        enrichTripsWithDirectionId(trips, stopTimesIndex, stopsIndex);
        
        const tripsIndex = {}; trips.forEach(t=>{ if(!t) return; const rid=t.route_id; if(!rid) return; if(!tripsIndex[rid]) tripsIndex[rid]=[]; tripsIndex[rid].push(t); });
const agenciesIndex = {};
agencies.forEach(a => {
  if (a && (a.agency_id || a.agency_name)) {
    agenciesIndex[a.agency_id || a.agency_name] = a;
  }
});

const logicalRoutes = buildLogicalRoutes(routes, agenciesIndex);

// FAZA 1.4 & 2.6: Clear caches when loading new data
clearStationCache();
clearStopsSearchIndex();
cachedGroupsArray = null;
lastStopsDataHash = null;

state.gtfsData = {
  routes,
  agencies,
  agenciesIndex,
  calendar,
  calendarDates,
  stopTimesIndex,
  stopsIndex,
  tripsIndex,
  logicalRoutes,
  trips,
  stops,
  shapesIndex
};
state.selectedRouteGroup = null;
// Invalidate canonical master lists and column order cache on new GTFS load
state.canonicalMasterLists = {};
state.columnOrderCache = {};
        if (routes.length === 1) {
          state.selectedRoute = routes[0];
          const routeTrips = state.gtfsData.tripsIndex[state.selectedRoute.route_id] || [];
          if (routeTrips.length>0) state.selectedDirection = [...new Set(routeTrips.map(t=>t.direction_id||'0'))][0];
        }
const dates = generateAvailableDates(calendar, calendarDates);
state.availableDates = dates;
if (dates.length > 0) {
  // Get today's date in GTFS format (YYYYMMDD)
  const today = new Date();
  const todayStr = today.getFullYear() + 
    String(today.getMonth() + 1).padStart(2, '0') + 
    String(today.getDate()).padStart(2, '0');
  
  // Find today's date or the closest earlier date
  let selectedDate = null;
  
  // Check if today exists in dates
  if (dates.some(d => d.value === todayStr)) {
    selectedDate = todayStr;
  } else {
    // Find the latest date that is before or equal to today
    const earlierDates = dates.filter(d => d.value <= todayStr);
    if (earlierDates.length > 0) {
      selectedDate = earlierDates[earlierDates.length - 1].value;
    } else {
      // If no earlier dates, use the first available date
      selectedDate = dates[0].value;
    }
  }
  
  state.selectedDate = selectedDate;
}

        state.loading=false; state.loadingStep=''; state.loadingProgress=0; state.loadingProgressPercent=0;
        render();
      } catch(err) {
        console.error('Error loading GTFS:', err);
        state.error = 'Błąd ładowania pliku GTFS: ' + err.message;
        state.loading=false; state.loadingProgress=0; state.loadingProgressPercent=0;
        render();
      }
    }

    function cancelParsing() {
      if (state.currentWorker) {
        try { state.currentWorker.terminate(); } catch(e){}
        state.currentWorker = null;
      }
      state.loading=false; state.loadingStep=''; state.loadingProgress=0; state.loadingProgressPercent=0;
      state.error = 'Parsowanie anulowane przez użytkownika';
      render();
    }

// ═══════════════════════════════════════════════════════════════
// 5. GTFS DATA PROCESSING
// ═══════════════════════════════════════════════════════════════
function canonicalFromCode(t) {
  if (t === null || t === undefined || t === '') return null;
  const n = parseInt(t, 10);
  if (isNaN(n)) return null;

  if (n === 0) return 'tram';
  if (n === 1) return 'metro';
  if (n === 2) return 'rail';
  if (n === 3) return 'bus';
  if (n === 4) return 'ferry';
  if (n === 5) return 'cable';
  if (n === 6) return 'gondola';
  if (n === 7) return 'funicular';
  if (n === 11) return 'trolleybus';
  if (n === 12) return 'monorail';
  if (n === 300) return 'rail';
  if (n >= 100 && n < 200) return 'rail';
  if (n >= 200 && n < 300) return 'coach';
  if (n >= 301 && n < 500) return 'metro';
  if (n >= 500 && n < 600) return 'ferry';
  if (n >= 700 && n < 800) return 'bus';
  if (n >= 800 && n < 900) return 'bus';
  if (n >= 900 && n < 1000) return 'tram';
  if (n >= 1100 && n < 1200) return 'air';
  if (n >= 1300 && n < 1400) return 'cable';
  return null;
}

function collectRouteType(route) {
  const reasons = [];
  if (!route || typeof route !== 'object') return { canonical: 'other', reasons: ['no-route'] };

  const rt = (route.route_type !== undefined && route.route_type !== '') ? route.route_type
           : (route.route_type_id !== undefined && route.route_type_id !== '') ? route.route_type_id
           : (route.type !== undefined && route.type !== '') ? route.type
           : '';

  if (rt !== '') {
    const byCode = canonicalFromCode(rt);
    if (byCode) {
      reasons.push(`code:${rt}->${byCode}`);
      return { canonical: byCode, reasons };
    } else {
      reasons.push(`code:${rt}`);
    }
  } else {
    reasons.push('no-code');
  }

  reasons.push('fallback:other');
  return { canonical: 'other', reasons: reasons };
}

    function getRouteTypeMeta(routeType) {
      const t = (routeType === null || routeType === undefined || routeType === '') ? null : parseInt(routeType, 10);
      const cm = state.customRouteTypeMap || {};
      if (t !== null && !isNaN(t)) {
        if (cm[t]) return cm[t];
        if (ROUTE_TYPE_META_EXTENDED[t]) return ROUTE_TYPE_META_EXTENDED[t];
        if (ROUTE_TYPE_META_BASIC[t]) return ROUTE_TYPE_META_BASIC[t];
      }
      return cm[3] || ROUTE_TYPE_META_BASIC[3] || { label:'Other', color:'#6b7280', weight:2 };
    }

function buildLogicalRoutes(routes, agenciesIndex) {
  const groupsMap = new Map();

  for (const r of routes) {
    if (!r) continue;

    const agencyKey = (r.agency_id || '').trim().toLowerCase();
    const shortRaw = (r.route_short_name || r.route_id || '').trim();
    const shortKey = shortRaw.toLowerCase();

    // używamy canonical route-type, żeby np. S-Bahn S1 != autobus S1
    const catInfo = collectRouteType(r);
    const cat = (catInfo && catInfo.canonical) ? catInfo.canonical : 'other';

    const key = agencyKey + '||' + cat + '||' + shortKey;

    if (!groupsMap.has(key)) {
      groupsMap.set(key, {
        id: key,
        agency_id: r.agency_id || '',
        route_short_name: shortRaw || r.route_id || '',
        canonical_type: cat,
        members: [],
      });
    }
    groupsMap.get(key).members.push(r);
  }

  const logicalRoutes = Array.from(groupsMap.values());

  logicalRoutes.sort((a, b) => {
    const ca = CANONICAL_CATEGORIES[a.canonical_type]?.order ?? 999;
    const cb = CANONICAL_CATEGORIES[b.canonical_type]?.order ?? 999;
    if (ca !== cb) return ca - cb;

    const na = String(a.route_short_name || '').trim();
    const nb = String(b.route_short_name || '').trim();
    return na.localeCompare(nb, undefined, { numeric: true, sensitivity: 'base' });
  });

  return logicalRoutes;
}

function getLogicalRouteKeyFromGroup(group) {
  if (!group) return null;
  return group.id || (group.agency_id || '') + '::' + (group.route_short_name || '');
}

function generateAvailableDates(calendar, calendarDates) {
  const dates = new Set();
  calendar.forEach(cal => {
    const startDate = parseGTFSDate(cal.start_date);
    const endDate = parseGTFSDate(cal.end_date);
    if (!startDate || !endDate) return;
    const current = new Date(startDate);
    while (current <= endDate) {
      const dayOfWeek = DAY_NAMES[current.getDay()];
      if (cal[dayOfWeek] === '1') dates.add(formatDateToGTFS(current));
      current.setDate(current.getDate() + 1);
    }
  });
  calendarDates.forEach(cd => {
    if (cd.exception_type === '1') dates.add(cd.date);
    else if (cd.exception_type === '2') dates.delete(cd.date);
  });

  return Array.from(dates)
    .sort()
    .map(dateStr => {
      const date = parseGTFSDate(dateStr);
      if (!date) return { value: dateStr, label: dateStr };
      const dd = String(date.getDate()).padStart(2, '0');
      const mm = String(date.getMonth() + 1).padStart(2, '0');
      const yyyy = String(date.getFullYear());
      return { value: dateStr, label: `${dd}-${mm}-${yyyy}` };
    });
}

    function getServicesForDate(dateStr) {
      if (!state.gtfsData) return [];
      const date = parseGTFSDate(dateStr); if (!date) return [];
      const dayOfWeek = DAY_NAMES[date.getDay()];
      const services = new Set();
      state.gtfsData.calendar.forEach(cal => {
        const startDate = parseGTFSDate(cal.start_date);
        const endDate = parseGTFSDate(cal.end_date);
        if (startDate && endDate && date >= startDate && date <= endDate && cal[dayOfWeek] === '1') services.add(cal.service_id);
      });
    if (state.gtfsData.calendarDates) {
      state.gtfsData.calendarDates.forEach(cd => {
        if (cd.date === dateStr) {
          if (cd.exception_type === '1') services.add(cd.service_id);
          else if (cd.exception_type === '2') services.delete(cd.service_id);
        }
      });
    }
    return Array.from(services);
    }

    function getWeekdayDate() {
      const today = parseGTFSDate(state.selectedDate);
      if (!today) return findDateForDayOfWeek(WEDNESDAY);
      const currentDayOfWeek = today.getDay();
      if (currentDayOfWeek >= 1 && currentDayOfWeek <= 5) return state.selectedDate;
      return findDateForDayOfWeek(WEDNESDAY);
    }

    function findDateForDayOfWeek(targetDayOfWeek) {
      const today = parseGTFSDate(state.selectedDate); if (!today) return null;
      const currentDayOfWeek = today.getDay();
      if (currentDayOfWeek === targetDayOfWeek) return state.selectedDate;
      for (let i=1;i<=7;i++){ const testDate = new Date(today); testDate.setDate(testDate.getDate()+i); if (testDate.getDay()===targetDayOfWeek) {
        const year=testDate.getFullYear(), month=String(testDate.getMonth()+1).padStart(2,'0'), day=String(testDate.getDate()).padStart(2,'0'); return `${year}${month}${day}`;
      }}
      return null;
    }

function buildStationNameCache(stopsIndex) {
  if (stationNameToIdCache) return stationNameToIdCache;
  
  stationNameToIdCache = new Map();
  
  // Znajdź wszystkie "stacje główne" - czyli stop_id które są parent_station dla innych
  const parentStationIds = new Set();
  Object.values(stopsIndex).forEach(stop => {
    if (stop.parent_station && stop.parent_station. trim()) {
      parentStationIds. add(stop.parent_station. trim());
    }
  });
  
  // Dla każdej stacji głównej, zapisz mapowanie nazwa → stop_id
  parentStationIds.forEach(parentId => {
    const parentStop = stopsIndex[parentId];
    if (parentStop?. stop_name) {
      const normalizedName = parentStop.stop_name.trim().replace(/\s+/g, ' ');
      stationNameToIdCache.set(normalizedName, parentId);
    }
  });
  
  return stationNameToIdCache;
}

function clearStationCache() {
  stationNameToIdCache = null;
}

function getStationId(stopId, stopsIndex) {
  const stop = stopsIndex[stopId];
  if (!stop) return stopId;
  
  // PRIORYTET 1: parent_station (jeśli istnieje)
  const parent = stop.parent_station;
  if (parent && parent.trim() !== '') {
    return parent. trim();
  }
  
  // PRIORYTET 2: Sprawdź czy nazwa pasuje do znanej stacji głównej
  if (stop.stop_name) {
    const normalizedName = stop.stop_name. trim().replace(/\s+/g, ' ');
    const cache = buildStationNameCache(stopsIndex);
    
    if (cache.has(normalizedName)) {
      return cache. get(normalizedName);
    }
    
    // Fallback: zwróć znormalizowaną nazwę
    return normalizedName;
  }
  
  return stopId;
}

function getStationIdWithPolicy(stopId, stopsIndex, allowedStationSet) {
  const stationId = getStationId(stopId, stopsIndex);
  if (!allowedStationSet || allowedStationSet.has(stationId)) return stationId;
  return stopId; // no merge if not allowed
}

// ═══════════════════════════════════════════════════════════════
// 6. ROUTE PROFILE & ANALYSIS
// ═══════════════════════════════════════════════════════════════
// === KROK 1: Budowa grafu trasy i profilu core dla logical route ===

// Helper: Normalize GTFS pickup/dropoff types (treat on-demand as passenger)
// Note: This is used during classification to treat on-demand (2,3) as regular passenger (0)
// For display purposes, on-demand detection happens before normalization
function normalizePickupDropoffType(value) {
  const normalized = String(value || '0').trim();
  // 2 = phone agency, 3 = coordinate with driver → treat as 0 (passenger)
  if (normalized === '2' || normalized === '3') return '0';
  return normalized;
}

// Helper: Calculate edge frequency per stop
function calculateStopEdgeFrequency(trips, tripStopMaps) {
  const edgeFrequency = {};
  const totalTrips = trips.length;
  
  // Safety check for empty trips
  if (totalTrips === 0) {
    return edgeFrequency;
  }
  
  trips.forEach(trip => {
    const stops = tripStopMaps[trip.trip_id] || [];
    for (let i = 0; i < stops.length - 1; i++) {
      const edge = stops[i].stop_id + '->' + stops[i + 1].stop_id;
      edgeFrequency[edge] = (edgeFrequency[edge] || 0) + 1;
    }
  });
  
  // Convert to percentages
  Object.keys(edgeFrequency).forEach(key => {
    edgeFrequency[key] = edgeFrequency[key] / totalTrips;
  });
  
  return edgeFrequency;
}

// Helper: Find low-frequency candidates with tier classification
function computeCoreBoundaryFrequency(edgeFrequency, coreStops) {
  // For each non-core stop, compute max frequency of edges connecting to any core stop
  // Returns Map: stop_id -> boundaryFreq
  const boundaryFreq = new Map();
  const coreSet = new Set(coreStops);
  
  Object.entries(edgeFrequency).forEach(([edge, freq]) => {
    const [from, to] = edge.split('->');
    
    // Check if edge crosses core boundary (one end is core, other is not)
    const fromIsCore = coreSet.has(from);
    const toIsCore = coreSet.has(to);
    
    if (fromIsCore && !toIsCore) {
      // core -> non-core
      const current = boundaryFreq.get(to) || 0;
      boundaryFreq.set(to, Math.max(current, freq));
    } else if (!fromIsCore && toIsCore) {
      // non-core -> core
      const current = boundaryFreq.get(from) || 0;
      boundaryFreq.set(from, Math.max(current, freq));
    }
  });
  
  return boundaryFreq;
}

function findLowFrequencyCandidates(edgeFrequency, allStops, threshold = 0.10) {
  const tier1 = new Set();  // <6%
  const tier2 = new Set();  // 6-10%
  
  allStops.forEach(stopId => {
    // Find all edges involving this stop
    const edges = Object.keys(edgeFrequency).filter(e => 
      e.startsWith(stopId + '->') || e.endsWith('->' + stopId)
    );
    
    // If ALL edges are below threshold → candidate
    const allLowFreq = edges.every(e => edgeFrequency[e] < threshold);
    
    // Skip if not a low-frequency candidate or has no edges
    if (!allLowFreq || edges.length === 0) return;
    
    // Calculate max edge frequency for this stop
    const maxEdgeFreq = Math.max(...edges.map(e => edgeFrequency[e]));
    
    // Classify into tiers
    if (maxEdgeFreq < 0.06) {
      tier1.add(stopId);
    } else if (maxEdgeFreq < threshold) {
      tier2.add(stopId);
    }
  });
  
  return { tier1, tier2 };
}

// Helper: Check if stop is between core start and end
function isStopBetweenCore(stopId, trip, coreStart, coreEnd) {
  // Find positions of stopId, coreStart, coreEnd in trip
  let stopIdx = -1;
  let coreStartIdx = -1;
  let coreEndIdx = -1;
  
  for (let i = 0; i < trip.length; i++) {
    if (trip[i].stop_id === stopId) stopIdx = i;
    if (trip[i].stop_id === coreStart) coreStartIdx = i;
    if (trip[i].stop_id === coreEnd) coreEndIdx = i;
  }
  
  // If stop is between coreStart and coreEnd → it's a passenger branch
  // Handle both forward and reverse directions
  if (coreStartIdx !== -1 && coreEndIdx !== -1 && stopIdx !== -1) {
    const minCoreIdx = Math.min(coreStartIdx, coreEndIdx);
    const maxCoreIdx = Math.max(coreStartIdx, coreEndIdx);
    return stopIdx > minCoreIdx && stopIdx < maxCoreIdx;
  }
  
  return false;
}

// Helper: Recursive tail detection with 2-tier classification
function classifyTailStopsRecursive(candidateTiers, trips, tripStopMaps, stopTimesIndex, coreStops) {
  const nodeTypes = {};
  const coreSet = new Set(coreStops);
  
  // Safety check: if no core stops, candidates will be classified in buildRouteProfileForCurrentSelection
  if (!coreStops || coreStops.length === 0) {
    return nodeTypes;
  }
  
  const coreStart = coreStops[0];
  const coreEnd = coreStops[coreStops.length - 1];
  
  // Extract tier sets
  const tier1Candidates = candidateTiers.tier1 || new Set();
  const tier2Candidates = candidateTiers.tier2 || new Set();
  
  let changed = true;
  let iterations = 0;
  const MAX_ITERATIONS = 10;
  
  // Initialize core stops with 'core' classification
  coreStops.forEach(stopId => {
    nodeTypes[stopId] = 'core';
  });
  
  // Helper function to classify a candidate with tier-specific fallback
  const classifyCandidate = (candidateId, fallbackType) => {
    // Skip if already classified
    if (nodeTypes[candidateId]) return false;
    
    // TEST 1: Check if candidate appears BETWEEN coreStart and coreEnd in any trip
    let appearsBetweenCore = false;
    
    for (const trip of trips) {
      const stops = tripStopMaps[trip.trip_id] || [];
      if (isStopBetweenCore(candidateId, stops, coreStart, coreEnd)) {
        appearsBetweenCore = true;
        break;
      }
    }
    
    if (appearsBetweenCore) {
      // Appears between core → passenger branch
      nodeTypes[candidateId] = 'passenger';
      return true;
    }
    
    // TEST 2: Get pickup/dropoff flags for this stop (check all occurrences)
    let hasPickup1 = false;
    let hasDropoff1 = false;
    let hasNormalFlags = false;
    
    trips.forEach(trip => {
      const stopTimes = stopTimesIndex[trip.trip_id] || [];
      const st = stopTimes.find(s => s.stop_id === candidateId);
      if (st) {
        const pickup = normalizePickupDropoffType(st.pickup_type);
        const dropoff = normalizePickupDropoffType(st.drop_off_type);
        
        if (pickup === '1' || dropoff === '1') {
          if (pickup === '1') hasPickup1 = true;
          if (dropoff === '1') hasDropoff1 = true;
        } else {
          hasNormalFlags = true;
        }
      }
    });
    
    // If ANY occurrence has pickup=1 OR dropoff=1 → tail
    if (hasPickup1 || hasDropoff1) {
      nodeTypes[candidateId] = 'tail';
      return true;
    }
    
    // TEST 3: If all flags are 0/0 (after normalization) → recursive test
    if (hasNormalFlags) {
      // Check: do ALL trips with this stop have a tail stop somewhere on their route?
      const tripsWithCandidate = trips.filter(trip => {
        const stops = tripStopMaps[trip.trip_id] || [];
        return stops.some(s => s.stop_id === candidateId);
      });
      
      let allTripsHaveOtherTails = true;
      
      for (const trip of tripsWithCandidate) {
        const stops = tripStopMaps[trip.trip_id] || [];
        
        // Get stops OUTSIDE core for this trip
        const stopsOutsideCore = stops.filter(s => !coreSet.has(s.stop_id));
        
        // Check if any stop outside core (excluding candidate itself) is marked as tail
        const hasTailOnRoute = stopsOutsideCore.some(s => 
          s.stop_id !== candidateId && nodeTypes[s.stop_id] === 'tail'
        );
        
        if (!hasTailOnRoute) {
          allTripsHaveOtherTails = false;
          break;
        }
      }
      
      if (allTripsHaveOtherTails && tripsWithCandidate.length > 0) {
        // All trips with this stop have a tail → this is part of depot route
        nodeTypes[candidateId] = 'tail';
        return true;
      }
    }
    
    // FALLBACK: Apply tier-specific default
    if (!nodeTypes[candidateId]) {
      nodeTypes[candidateId] = fallbackType;
      return true; // Count as changed when we make any classification
    }
    
    return false;
  };
  
  while (changed && iterations < MAX_ITERATIONS) {
    changed = false;
    iterations++;
    
    // Process TIER 1 first (ultra-low, bias: TAIL)
    tier1Candidates.forEach(candidateId => {
      if (classifyCandidate(candidateId, 'tail')) {
        changed = true;
      }
    });
    
    // Then process TIER 2 (low, bias: PASSENGER)
    tier2Candidates.forEach(candidateId => {
      if (classifyCandidate(candidateId, 'passenger')) {
        changed = true;
      }
    });
  }
  
  return nodeTypes;
}

function getCurrentRouteProfile() {
  if (!state.selectedRoute || !state.gtfsData) return null;

  const dir = state.selectedDirection || '0';

  // Ustal klucz
  let key;
  if (state.selectedRouteGroup) {
    key = getLogicalRouteKeyFromGroup(state.selectedRouteGroup);
    if (!key) return null;
  } else {
    key = 'raw::' + (state.selectedRoute.route_id || '');
  }

  // Sprawdź czy pełny profile już istnieje (cache)
  if (state.routeProfiles[key] && state.routeProfiles[key][dir]) {
    return state.routeProfiles[key][dir];
  }

  // NIE MA - zbuduj teraz (lazy loading)
  return buildRouteProfileForCurrentSelection();
}

function buildRouteProfileForCurrentSelection() {
  if (!state.selectedRoute || !state.gtfsData) return null;

  const dir = state.selectedDirection || '0';

  // 1. Ustal klucz logicznej linii
  let key;
  let memberRoutes = [];

  if (state.selectedRouteGroup && Array.isArray(state.selectedRouteGroup.members)) {
    key = getLogicalRouteKeyFromGroup(state.selectedRouteGroup);
    memberRoutes = state.selectedRouteGroup.members;
  } else {
    key = 'raw::' + (state.selectedRoute.route_id || '');
    memberRoutes = [state.selectedRoute];
  }

  if (!key) return null;

  // 2. Cache
  if (state.routeProfiles[key] && state.routeProfiles[key][dir]) {
    return state.routeProfiles[key][dir];
  }

  const { stopTimesIndex, tripsIndex, stopsIndex } = state.gtfsData;
  if (!stopTimesIndex || !tripsIndex || !stopsIndex) return null;

  // 3. Zbierz trips tej logical linii + kierunku (bez filtra daty)
  let routeIds = memberRoutes.map(r => r.route_id).filter(Boolean);
  if (!routeIds.length) return null;

  let allTrips = [];
  routeIds.forEach(rid => {
    const ts = tripsIndex[rid] || [];
    allTrips = allTrips.concat(ts);
  });

  allTrips = allTrips.filter(t => (t.direction_id || '0') === dir);
  if (!allTrips.length) return null;

  // === NOWA LOGIKA: Budowanie wzorcowej trasy ===
  const CORE_THRESHOLD = 0.10; // 10%

  // Zlicz krawędzie między STACJAMI (nie przystankami)
  const stationEdgeFrequency = {};
  const allTripStationData = []; // będziemy potrzebować później

  allTrips.forEach(trip => {
    const stsRaw = stopTimesIndex[trip.trip_id] || [];
    const sts = stsRaw
      .filter(st => st && st.stop_id)
      .sort((a, b) => parseInt(a.stop_sequence || '0') - parseInt(b.stop_sequence || '0'));
    
    const stationIds = sts.map(st => getStationId(st.stop_id, stopsIndex));
    
    // Zapisz dane tripu do późniejszego użycia
    allTripStationData.push({
      tripId: trip.trip_id,
      stationIds: stationIds,
      stopIds: sts.map(st => st.stop_id)
    });
    
    // Zlicz krawędzie
    for (let i = 0; i < stationIds.length - 1; i++) {
      const edge = stationIds[i] + '→' + stationIds[i + 1];
      stationEdgeFrequency[edge] = (stationEdgeFrequency[edge] || 0) + 1;
    }
  });

  // Compute stationMergeAllowed: stations that appear at most once per trip
  const stationMaxOccurrence = new Map();
  allTripStationData.forEach(({ stationIds }) => {
    const stationCounts = new Map();
    stationIds.forEach(stationId => {
      stationCounts.set(stationId, (stationCounts.get(stationId) || 0) + 1);
    });
    stationCounts.forEach((count, stationId) => {
      const currentMax = stationMaxOccurrence.get(stationId) || 0;
      if (count > currentMax) {
        stationMaxOccurrence.set(stationId, count);
      }
    });
  });
  const stationMergeAllowed = new Set();
  stationMaxOccurrence.forEach((maxCount, stationId) => {
    if (maxCount <= 1) {
      stationMergeAllowed.add(stationId);
    }
  });

  // Określ wzorcowe krawędzie i stacje
  const totalTripsCount = allTrips.length;
  const coreStationsSet = new Set();

  Object.entries(stationEdgeFrequency).forEach(([edge, count]) => {
    if (count / totalTripsCount >= CORE_THRESHOLD) {
      const [from, to] = edge.split('→');
      coreStationsSet.add(from);
      coreStationsSet.add(to);
    }
  });

  // Dla każdego tripa oblicz firstCoreIdx i lastCoreIdx
  const tripCoreIndices = {};
  allTripStationData.forEach(({ tripId, stationIds, stopIds }) => {
    const isCore = stationIds.map(sid => coreStationsSet.has(sid));
    const firstCoreIdx = isCore.indexOf(true);
    const lastCoreIdx = isCore.lastIndexOf(true);
    
    tripCoreIndices[tripId] = {
      firstCoreIdx,
      lastCoreIdx,
      stationIds,
      stopIds
    };
  });

  // 4. Graf z stop_sequence + pickup/drop_off (pasażerski)
  const nodes = {}; // stop_id → info
  const edges = {}; // "A->B" → info
  const tripCount = allTrips.length;

  function edgeKey(a, b) {
    return a + '->' + b;
  }

  allTrips.forEach(trip => {
    const stsRaw = stopTimesIndex[trip.trip_id] || [];

    const sts = stsRaw
      .filter(st => st && st.stop_id)
      .sort((a, b) => (parseInt(a.stop_sequence || '0', 10) - parseInt(b.stop_sequence || '0', 10)));

    const passengerStops = [];
    sts.forEach(st => {
      const stId = st.stop_id;
      const pickup = st.pickup_type;
      const dropoff = st.drop_off_type;

      // GTFS: 1 = no pickup/dropoff; 0 = normal
      if (pickup === '1' && dropoff === '1') {
        return; // stricte techniczne – pomijamy
      }

      passengerStops.push(st);
      if (!nodes[stId]) {
        const stop = stopsIndex[stId] || {};
        nodes[stId] = {
          id: stId,
          name: stop.stop_name || stId,
          visitCount: 0,
          inDegree: 0,
          outDegree: 0,
        };
      }
      nodes[stId].visitCount++;
    });

    for (let i = 0; i < passengerStops.length - 1; i++) {
      const a = passengerStops[i].stop_id;
      const b = passengerStops[i + 1].stop_id;
      const k = edgeKey(a, b);
      if (!edges[k]) {
        edges[k] = {
          from: a,
          to: b,
          count: 0,
          trips: new Set(),
        };
      }
      edges[k].count++;
      edges[k].trips.add(trip.trip_id);
      if (nodes[a]) nodes[a].outDegree++;
      if (nodes[b]) nodes[b].inDegree++;
    }
  });

  // 5. Wstępne „mocne” krawędzie jako kandydaci kręgosłupa
  const coreEdges = new Set();
  const minCoreFraction = 0.4; // heurystyka: ≥ 40% trips

  Object.values(edges).forEach(e => {
    const frac = e.count / tripCount;
    if (frac >= minCoreFraction) {
      coreEdges.add(edgeKey(e.from, e.to));
    }
  });

  // 6. Z coreEdges spróbuj zbudować najdłuższą ścieżkę
  const coreAdj = {};
  const coreInDeg = {};
  coreEdges.forEach(k => {
    const e = edges[k];
    if (!e) return;
    if (!coreAdj[e.from]) coreAdj[e.from] = [];
    coreAdj[e.from].push(e.to);
    coreInDeg[e.to] = (coreInDeg[e.to] || 0) + 1;
    if (!coreInDeg[e.from]) coreInDeg[e.from] = coreInDeg[e.from] || 0;
  });

  const coreStartCandidates = Object.keys(coreInDeg).filter(sid => (coreInDeg[sid] || 0) === 0);
  const visitedCore = new Set();
  let bestCorePath = [];

  function dfsCore(startId, path) {
    path.push(startId);
    visitedCore.add(startId);
    const nexts = coreAdj[startId] || [];
    if (!nexts.length) {
      if (path.length > bestCorePath.length) {
        bestCorePath = path.slice();
      }
    } else {
      nexts.forEach(nid => {
        if (!visitedCore.has(nid)) {
          dfsCore(nid, path);
        } else {
          if (path.length > bestCorePath.length) {
            bestCorePath = path.slice();
          }
        }
      });
    }
    path.pop();
    visitedCore.delete(startId);
  }

  if (coreStartCandidates.length) {
    coreStartCandidates.forEach(sid => dfsCore(sid, []));
  } else {
    Object.keys(coreAdj).forEach(sid => dfsCore(sid, []));
  }

  const coreStops = bestCorePath.filter(sid => nodes[sid]);

  const coreSet = new Set(coreStops);

  // Wstępne typy krawędzi core/noncore
  const edgeTypes = {};
  Object.keys(edges).forEach(k => {
    const e = edges[k];
    if (coreSet.has(e.from) && coreSet.has(e.to) && coreEdges.has(k)) {
      edgeTypes[k] = 'core';
    } else {
      edgeTypes[k] = 'noncore';
    }
  });

// --- 7. NEW: Recursive Tail Detection Algorithm ---
  
  // 7.1: Build tripStopMaps for the helper functions
  const tripStopMaps = {};
  allTrips.forEach(trip => {
    const stsRaw = stopTimesIndex[trip.trip_id] || [];
    const sts = stsRaw
      .filter(st => st && st.stop_id)
      .sort((a, b) => parseInt(a.stop_sequence || '0') - parseInt(b.stop_sequence || '0'));
    tripStopMaps[trip.trip_id] = sts;
  });
  
  // 7.2: Calculate edge frequency
  const edgeFrequency = calculateStopEdgeFrequency(allTrips, tripStopMaps);
  
  // 7.3: Find all stop IDs
  const allStopIds = new Set();
  allTrips.forEach(trip => {
    const stops = tripStopMaps[trip.trip_id] || [];
    stops.forEach(st => allStopIds.add(st.stop_id));
  });
  
  // 7.4: Find low-frequency candidates with tier classification (threshold 10%)
  const candidateTiers = findLowFrequencyCandidates(edgeFrequency, Array.from(allStopIds), 0.10);
  
  // 7.4b: Core-boundary frequency gating
  const boundaryFreq = computeCoreBoundaryFrequency(edgeFrequency, coreStops);
  const tier1Boundary = new Set();
  const tier2Boundary = new Set();
  
  boundaryFreq.forEach((freq, stopId) => {
    if (freq < 0.06) {
      tier1Boundary.add(stopId);
    } else if (freq < 0.10) {
      tier2Boundary.add(stopId);
    }
  });
  
  // Merge boundary candidates with existing candidates
  const mergedTiers = {
    tier1: new Set([...candidateTiers.tier1, ...tier1Boundary]),
    tier2: new Set([...candidateTiers.tier2, ...tier2Boundary])
  };
  
  // 7.5: Classify stops recursively with tier-specific fallbacks
  const nodeTypes = classifyTailStopsRecursive(
    mergedTiers,
    allTrips,
    tripStopMaps,
    stopTimesIndex,
    coreStops
  );
  
  // 7.6: Ensure all stops have a classification (fallback to 'passenger' for safety)
  // Using 'passenger' instead of 'noncore' ensures unclassified stops are visible
  allStopIds.forEach(stopId => {
    if (!nodeTypes[stopId]) {
      nodeTypes[stopId] = 'passenger';
    }
  });

  // 8. Collect detailed stop metadata (pickup/drop_off types, positions in routes)
  const stopMetadata = {}; // stop_id → { hasPickup1: bool, hasDropOff1: bool, isOnDemand: bool, isFirstWithNoPickup: bool, isLastWithNoDropOff: bool }
  
  allTrips.forEach(trip => {
    const stsRaw = stopTimesIndex[trip.trip_id] || [];
    const sts = stsRaw
      .filter(st => st && st.stop_id)
      .sort((a, b) => (parseInt(a.stop_sequence || '0', 10) - parseInt(b.stop_sequence || '0', 10)));
    
    sts.forEach((st, i) => {
      const stId = st.stop_id;
      const pType = String(st.pickup_type || '0').trim();
      const dType = String(st.drop_off_type || '0').trim();
      
      if (!stopMetadata[stId]) {
        stopMetadata[stId] = {
          hasPickup1: false,
          hasDropOff1: false,
          isStrictlyTechnical: false,
          isOnDemand: false,
          isFirstWithNoPickup: false,
          isLastWithNoDropOff: false,
        };
      }
      
      const meta = stopMetadata[stId];
      
      // Zbierz informacje o pickup/drop_off types
      if (pType === '1') meta.hasPickup1 = true;
      if (dType === '1') meta.hasDropOff1 = true;
      if (pType === '1' && dType === '1') meta.isStrictlyTechnical = true;
      if (pType === '2' || pType === '3' || dType === '2' || dType === '3') {
        meta.isOnDemand = true;
      }
      
      // Sprawdź czy to pierwszy przystanek z pickup_type=1
      if (i === 0 && pType === '1') {
        meta.isFirstWithNoPickup = true;
      }
      
      // Sprawdź czy to ostatni przystanek z drop_off_type=1
      if (i === sts.length - 1 && dType === '1') {
        meta.isLastWithNoDropOff = true;
      }
    });
  });

  // 9. Save profile to state
  if (!state.routeProfiles[key]) state.routeProfiles[key] = {};
  const profile = {
    key,
    direction: dir,
    tripCount,
    nodes,
    edges: Object.fromEntries(
      Object.entries(edges).map(([k, e]) => [k, { ...e, trips: Array.from(e.trips), type: edgeTypes[k] }])
    ),
    coreStops,
    nodeTypes,
    stopMetadata,
    coreStationsSet: coreStationsSet,
    tripCoreIndices: tripCoreIndices,
    stationMergeAllowed: stationMergeAllowed,
    version: 3,
  };
  state.routeProfiles[key][dir] = profile;
  return profile;
}

function buildMasterList(sortedTrips, tripStopMaps, stopsIndex) {
  // Step 1: Get core stops from profile
  const profile = getCurrentRouteProfile();
  if (!profile || !profile.coreStops) {
    // This should never happen, but fail gracefully
    return [];
  }
  
  const coreStops = profile.coreStops;
  const allowedSet = profile.stationMergeAllowed;
  
  // Step 2: Group core stops by station (merged stops)
  const stopsByStation = new Map();
  
  coreStops.forEach(stopId => {
    const stationId = getStationIdWithPolicy(stopId, stopsIndex, allowedSet);
    if (!stopsByStation.has(stationId)) {
      stopsByStation.set(stationId, []);
    }
    stopsByStation.get(stationId).push(stopId);
  });
  
  // Step 3: Build base master list from core
  const getStationDisplayName = (stationId, stopIds) => {
    if (stopsIndex[stationId]?.stop_name) {
      return stopsIndex[stationId].stop_name;
    }
    const firstStop = stopsIndex[stopIds[0]];
    return firstStop?.stop_name || stationId;
  };

  // Base master list = core stops grouped by station
  const masterList = Array.from(stopsByStation.entries()).map(([stationId, stopIds]) => ({
    id: stopIds[0],
    name: getStationDisplayName(stationId, stopIds),
    stopIds: stopIds
  }));
  
  // Step 4: Add branch stops (stops outside core)
  // Cache stationId for each masterList entry for performance
  const masterListStationIds = masterList.map(entry => {
    return getStationIdWithPolicy(entry.stopIds[0], stopsIndex, allowedSet);
  });
  
  // Process all trips to add stops not in core
  sortedTrips.forEach(trip => {
    const tripStops = tripStopMaps[trip.trip_id] || [];
    let lastMasterIdx = -1;
    
    tripStops.forEach(stopTime => {
      const stopId = stopTime.stop_id;
      const stationId = getStationIdWithPolicy(stopId, stopsIndex, allowedSet);
      
      // Find if this station already exists in masterList
      let existingIdx = -1;
      for (let i = 0; i < masterListStationIds.length; i++) {
        if (masterListStationIds[i] === stationId) {
          existingIdx = i;
          break;
        }
      }
      
      if (existingIdx !== -1) {
        // Station already exists - add stop_id if not present
        if (!masterList[existingIdx].stopIds.includes(stopId)) {
          masterList[existingIdx].stopIds.push(stopId);
        }
        lastMasterIdx = existingIdx;
      } else {
        // NEW station - insert RIGHT AFTER the last common stop
        const newEntry = {
          id: stopId,
          name: getStationDisplayName(stationId, [stopId]),
          stopIds: [stopId]
        };
        
        // Insert after lastMasterIdx (or at beginning if no common stop yet)
        const insertPos = lastMasterIdx + 1;
        masterList.splice(insertPos, 0, newEntry);
        masterListStationIds.splice(insertPos, 0, stationId);
        lastMasterIdx = insertPos;
      }
    });
  });
  
  return masterList;
}

function createTripMappings(sortedTrips, tripStopMaps, masterList) {
  return sortedTrips.map(trip => {
    const mapping = {}; let lastM = -1;
    const tripStops = tripStopMaps[trip.trip_id] || [];
    tripStops.forEach(s => {
      const sId = s.stop_id;
      for (let i = lastM+1;i<masterList.length;i++){
if ((masterList[i].stopIds && masterList[i].stopIds.includes(sId)) || 
    (!masterList[i].stopIds && masterList[i].id === sId)) {
  mapping[i] = s;
  lastM = i;
  break;
}
      }
    });
    return mapping;
  });
}

// ═══════════════════════════════════════════════════════════════
// 6B. CANONICAL MASTER LIST (STABLE ROW ORDER)
// ═══════════════════════════════════════════════════════════════
// 
// PURPOSE: Create a stable, canonical master list of stops (rows) per route/group and direction.
// The canonical list is built ONCE from ALL trips (no date filter, tail included) and cached.
// At render time, only row VISIBILITY is filtered - rows are never reordered.
// 
// ALGORITHM:
// 1. Use route profile's coreStops to define segments:
//    - Pre-core: stops before first core (variant starting points)
//    - Windows: stops between consecutive core stations (branches)
//    - Post-core: stops after last core (variant ending points)
// 2. For each segment, collect all stations that appear in that segment
// 3. Rank stations by median normalized position within the segment
// 4. Stable tie-breaking: name (alphabetical), then stop_id
// 5. Build canonical rows: pre-core, first core, [windows with branches], last core, post-core
// 6. Preserve nodeType (tail/passenger/core) from profile for each row
// 
// RENDERING:
// - Rows are filtered by: (a) tail toggle, (b) date (no departures = hidden)
// - Row order NEVER changes - only visibility
// - Columns (trips) are reordered separately using adjacent-swaps algorithm for chronological order
// 
// CACHE INVALIDATION:
// - On GTFS load (new data)
// - On route/group change
// - On direction change
// ═══════════════════════════════════════════════════════════════

/**
 * Get the canonical cache key for the current route/group selection
 * Returns a key like 'group::123' or 'raw::route_id'
 */
function getCanonicalKeyForCurrentSelection() {
  if (!state.selectedRoute) return null;
  
  let key;
  if (state.selectedRouteGroup) {
    key = getLogicalRouteKeyFromGroup(state.selectedRouteGroup);
  } else {
    key = 'raw::' + (state.selectedRoute.route_id || '');
  }
  return key;
}

/**
 * Build a canonical master list from ALL trips (no date filter, tail included).
 * This list is stable per route/group + direction and never changes.
 * Only visibility is filtered at render time.
 * 
 * Algorithm:
 * 1. Get core stops from profile (ordered sequence of main stations)
 * 2. Define segments: pre-core, windows between consecutive cores, post-core
 * 3. For each segment, collect all branch stations that appear in that segment
 * 4. Rank branch stations by median normalized position within the segment
 * 5. Stable tie-breaking: name, then stop_id
 * 6. Build final list: pre-core, first core, [windows with branches], last core, post-core
 * 
 * Pre-core: Stops before the first core station (e.g., variant starting points)
 * Post-core: Stops after the last core station (e.g., variant ending points)
 */
function buildCanonicalMasterList(profile, allTrips, stopTimesIndex, stopsIndex) {
  if (!profile || !profile.coreStops || profile.coreStops.length === 0) {
    return null; // Fallback to old behavior
  }

  const coreStops = profile.coreStops;
  const nodeTypes = profile.nodeTypes || {};
  const allowedSet = profile.stationMergeAllowed;
  
  // Helper to get station display name
  const getStationDisplayName = (stationId, stopIds) => {
    if (stopsIndex[stationId]?.stop_name) {
      return stopsIndex[stationId].stop_name;
    }
    const firstStop = stopsIndex[stopIds[0]];
    return firstStop?.stop_name || stationId;
  };

  // Step 1: Build core stations list (merged by station)
  const coreStationGroups = [];
  const seenStations = new Set();
  
  coreStops.forEach(stopId => {
    const stationId = getStationIdWithPolicy(stopId, stopsIndex, allowedSet);
    if (!seenStations.has(stationId)) {
      seenStations.add(stationId);
      coreStationGroups.push({
        stationId,
        stopIds: [stopId],
        isCore: true
      });
    } else {
      // Add to existing core station group
      const group = coreStationGroups.find(g => g.stationId === stationId);
      if (group && !group.stopIds.includes(stopId)) {
        group.stopIds.push(stopId);
      }
    }
  });

  // Step 2: Build windows between consecutive core stations
  // For each window [coreIdx -> coreIdx+1], collect branch stations
  const windows = [];
  for (let i = 0; i < coreStationGroups.length - 1; i++) {
    windows.push({
      startCore: coreStationGroups[i],
      endCore: coreStationGroups[i + 1],
      branches: new Map() // stationId -> { stopIds: [], positions: [] }
    });
  }

  // Step 2b: Pre-core and post-core segments
  const preCore = new Map(); // stationId -> { stopIds: [], positions: [] }
  const postCore = new Map(); // stationId -> { stopIds: [], positions: [] }

  // Step 3: Process all trips to collect branch stations and their positions
  allTrips.forEach(trip => {
    const stopTimes = stopTimesIndex[trip.trip_id] || [];
    const sortedStops = stopTimes
      .filter(st => st && st.stop_id)
      .sort((a, b) => parseInt(a.stop_sequence || '0') - parseInt(b.stop_sequence || '0'));

    if (sortedStops.length === 0) return;

    // Map stop positions in this trip
    const stopPositions = new Map();
    sortedStops.forEach((st, idx) => {
      stopPositions.set(st.stop_id, idx);
    });

    // Find positions of core stations in this trip
    const corePositions = coreStationGroups.map(coreGroup => {
      for (const stopId of coreGroup.stopIds) {
        if (stopPositions.has(stopId)) {
          return { coreGroup, position: stopPositions.get(stopId), stopId };
        }
      }
      return null;
    }).filter(x => x !== null);

    // Find first and last core positions in this trip
    const firstCorePos = corePositions.length > 0 
      ? Math.min(...corePositions.map(cp => cp.position))
      : -1;
    const lastCorePos = corePositions.length > 0
      ? Math.max(...corePositions.map(cp => cp.position))
      : -1;

    // Collect pre-core stops (before first core)
    if (firstCorePos > 0) {
      for (let pos = 0; pos < firstCorePos; pos++) {
        const stopTime = sortedStops[pos];
        const stopId = stopTime.stop_id;
        const stationId = getStationIdWithPolicy(stopId, stopsIndex, allowedSet);
        
        // Skip if this is a core station
        if (seenStations.has(stationId)) continue;
        
        // Normalize position relative to firstCorePos [0, 1)
        const normalizedPos = pos / firstCorePos;
        
        if (!preCore.has(stationId)) {
          preCore.set(stationId, {
            stopIds: [stopId],
            positions: [normalizedPos]
          });
        } else {
          const branch = preCore.get(stationId);
          if (!branch.stopIds.includes(stopId)) {
            branch.stopIds.push(stopId);
          }
          branch.positions.push(normalizedPos);
        }
      }
    }

    // Collect post-core stops (after last core)
    if (lastCorePos >= 0 && lastCorePos < sortedStops.length - 1) {
      const tripLength = sortedStops.length;
      for (let pos = lastCorePos + 1; pos < tripLength; pos++) {
        const stopTime = sortedStops[pos];
        const stopId = stopTime.stop_id;
        const stationId = getStationIdWithPolicy(stopId, stopsIndex, allowedSet);
        
        // Skip if this is a core station
        if (seenStations.has(stationId)) continue;
        
        // Normalize position relative to trip length [0, 1)
        const normalizedPos = (pos - lastCorePos) / (tripLength - lastCorePos);
        
        if (!postCore.has(stationId)) {
          postCore.set(stationId, {
            stopIds: [stopId],
            positions: [normalizedPos]
          });
        } else {
          const branch = postCore.get(stationId);
          if (!branch.stopIds.includes(stopId)) {
            branch.stopIds.push(stopId);
          }
          branch.positions.push(normalizedPos);
        }
      }
    }

    // For each window, collect branches
    for (let winIdx = 0; winIdx < windows.length; winIdx++) {
      const window = windows[winIdx];
      
      // Find positions of start and end core in this trip
      const startPos = corePositions.find(cp => cp.coreGroup === window.startCore);
      const endPos = corePositions.find(cp => cp.coreGroup === window.endCore);
      
      if (!startPos || !endPos || startPos.position >= endPos.position) {
        continue; // Skip if window not traversed in this trip
      }

      // Collect all stations between start and end (exclusive)
      const windowLength = endPos.position - startPos.position;
      
      for (let pos = startPos.position + 1; pos < endPos.position; pos++) {
        const stopTime = sortedStops[pos];
        const stopId = stopTime.stop_id;
        const stationId = getStationIdWithPolicy(stopId, stopsIndex, allowedSet);
        
        // Skip if this is a core station
        if (seenStations.has(stationId)) continue;
        
        // Calculate normalized position within window [0, 1]
        const normalizedPos = (pos - startPos.position) / windowLength;
        
        if (!window.branches.has(stationId)) {
          window.branches.set(stationId, {
            stopIds: [stopId],
            positions: [normalizedPos]
          });
        } else {
          const branch = window.branches.get(stationId);
          if (!branch.stopIds.includes(stopId)) {
            branch.stopIds.push(stopId);
          }
          branch.positions.push(normalizedPos);
        }
      }
    }
  });

  // Step 4: Rank branch stations by median position and build final list
  const finalRows = [];
  
  // Helper function to create sorted branch entries from a Map
  const createSortedBranchEntries = (branchMap) => {
    const branchEntries = Array.from(branchMap.entries()).map(([stationId, data]) => {
      // Calculate median position
      const sorted = data.positions.slice().sort((a, b) => a - b);
      const mid = Math.floor(sorted.length / 2);
      const median = sorted.length % 2 === 0
        ? (sorted[mid - 1] + sorted[mid]) / 2
        : sorted[mid];
      
      const stopName = getStationDisplayName(stationId, data.stopIds);
      
      return {
        stationId,
        stopIds: data.stopIds,
        median,
        name: stopName,
        primaryStopId: data.stopIds[0]
      };
    });

    // Sort by median, then by name, then by stop_id (stable)
    branchEntries.sort((a, b) => {
      if (a.median !== b.median) return a.median - b.median;
      if (a.name !== b.name) return a.name.localeCompare(b.name);
      return a.primaryStopId.localeCompare(b.primaryStopId);
    });

    return branchEntries;
  };

  // Add pre-core stops (before first core station)
  const preCoreBranches = createSortedBranchEntries(preCore);
  preCoreBranches.forEach(branch => {
    finalRows.push({
      id: branch.primaryStopId,
      name: branch.name,
      stopIds: branch.stopIds,
      nodeType: nodeTypes[branch.primaryStopId] || 'passenger'
    });
  });
  
  // Add first core station
  finalRows.push({
    id: coreStationGroups[0].stopIds[0],
    name: getStationDisplayName(coreStationGroups[0].stationId, coreStationGroups[0].stopIds),
    stopIds: coreStationGroups[0].stopIds,
    nodeType: nodeTypes[coreStationGroups[0].stopIds[0]] || 'core'
  });

  // For each window, add sorted branches, then the next core station
  windows.forEach((window, winIdx) => {
    // Sort branches by median position
    const branchEntries = createSortedBranchEntries(window.branches);

    // Add branches to final list
    branchEntries.forEach(branch => {
      finalRows.push({
        id: branch.primaryStopId,
        name: branch.name,
        stopIds: branch.stopIds,
        nodeType: nodeTypes[branch.primaryStopId] || 'passenger'
      });
    });

    // Add next core station
    const nextCore = window.endCore;
    finalRows.push({
      id: nextCore.stopIds[0],
      name: getStationDisplayName(nextCore.stationId, nextCore.stopIds),
      stopIds: nextCore.stopIds,
      nodeType: nodeTypes[nextCore.stopIds[0]] || 'core'
    });
  });

  // Add post-core stops (after last core station)
  const postCoreBranches = createSortedBranchEntries(postCore);
  postCoreBranches.forEach(branch => {
    finalRows.push({
      id: branch.primaryStopId,
      name: branch.name,
      stopIds: branch.stopIds,
      nodeType: nodeTypes[branch.primaryStopId] || 'passenger'
    });
  });

  return finalRows;
}

/**
 * Ensure canonical master list exists for current selection.
 * Returns the canonical master list or null if fallback needed.
 */
function ensureCanonicalMasterListForCurrentSelection() {
  const key = getCanonicalKeyForCurrentSelection();
  if (!key) return null;
  
  const dir = state.selectedDirection || '0';
  
  // Check cache
  if (state.canonicalMasterLists[key] && state.canonicalMasterLists[key][dir]) {
    return state.canonicalMasterLists[key][dir];
  }

  // Need to build it
  const profile = getCurrentRouteProfile();
  if (!profile || !profile.coreStops || profile.coreStops.length === 0) {
    return null; // Fallback
  }

  // Get ALL trips for this route/group + direction (no date filter)
  const { stopTimesIndex, tripsIndex, stopsIndex } = state.gtfsData;
  if (!stopTimesIndex || !tripsIndex || !stopsIndex) return null;

  let routeIds = [];
  if (state.selectedRouteGroup && Array.isArray(state.selectedRouteGroup.members)) {
    routeIds = state.selectedRouteGroup.members.map(r => r.route_id).filter(Boolean);
  } else if (state.selectedRoute) {
    routeIds = [state.selectedRoute.route_id];
  }

  if (!routeIds.length) return null;

  let allTrips = [];
  routeIds.forEach(rid => {
    const ts = tripsIndex[rid] || [];
    allTrips = allTrips.concat(ts);
  });

  allTrips = allTrips.filter(t => (t.direction_id || '0') === dir);
  if (!allTrips.length) return null;

  // Build canonical list
  const rows = buildCanonicalMasterList(profile, allTrips, stopTimesIndex, stopsIndex);
  
  if (!rows) return null;

  // Cache it
  if (!state.canonicalMasterLists[key]) {
    state.canonicalMasterLists[key] = {};
  }
  state.canonicalMasterLists[key][dir] = rows;

  return rows;
}

/**
 * Invalidate canonical cache for current route/group.
 * Called when route, group, or direction changes.
 */
function invalidateCanonicalCacheForCurrentSelection() {
  const key = getCanonicalKeyForCurrentSelection();
  if (key && state.canonicalMasterLists[key]) {
    delete state.canonicalMasterLists[key];
  }
  // Also clear column order cache
  state.columnOrderCache = {};
}

// ═══════════════════════════════════════════════════════════════
// 7. TRIP & VARIANT PROCESSING
// ═══════════════════════════════════════════════════════════════
function getAllTripsForRoute() {
  if (!state.selectedRoute || !state.gtfsData || !state.selectedDate) return [];

  let routeIds = [state.selectedRoute.route_id];
  if (state.selectedRouteGroup && Array.isArray(state.selectedRouteGroup.members)) {
    routeIds = state.selectedRouteGroup.members
      .map(r => r.route_id)
      .filter(Boolean);
  }

  let routeTrips = [];
  routeIds.forEach(rid => {
    const arr = state.gtfsData.tripsIndex[rid] || [];
    routeTrips = routeTrips.concat(arr);
  });

  routeTrips = routeTrips.filter(t => (t.direction_id || '0') === state.selectedDirection);
  const activeServices = getServicesForDate(state.selectedDate);
  return routeTrips.filter(t => activeServices.includes(t.service_id));
}

    function computeVariantsForRoute() {
      if (!state.selectedRoute || !state.gtfsData || !state.selectedDate) return null;
      const trips = getAllTripsForRoute();
      if (trips.length === 0) return null;
      const tripStopMaps = {};
      trips.forEach(trip => {
        const stopTimes = state.gtfsData.stopTimesIndex[trip.trip_id] || [];
        stopTimes.sort((a,b) => parseInt(a.stop_sequence || '0') - parseInt(b.stop_sequence || '0'));
        tripStopMaps[trip.trip_id] = stopTimes;
      });
      const patternToVariant = {}, tripToVariant = {}; let variantNum = 1;
      trips.forEach(trip => {
        const stops = tripStopMaps[trip.trip_id] || [];
        const patternKey = stops.map(st => st.stop_id).join(',');
        if (!patternToVariant[patternKey]) patternToVariant[patternKey] = variantNum++;
        tripToVariant[trip.trip_id] = patternToVariant[patternKey];
      });
      const variantDetails = {};
      Object.keys(patternToVariant).forEach(patternKey => {
        const vNum = patternToVariant[patternKey];
        const stopIds = patternKey ? patternKey.split(',') : [];
        variantDetails[vNum] = { stops: stopIds, stopDetails: stopIds.map(id => state.gtfsData.stopsIndex[id]) };
      });
      return { trips, tripStopMaps, tripToVariant, patternToVariant, variantDetails };
    }

function sortTripsByMostFrequentStop(trips, tripStopMaps, stopsIndex) {
  if (!trips || trips.length === 0) return trips;
  if (!stopsIndex) {
    // Fallback: chronological sort
    return trips.sort((a, b) => {
      const aStops = tripStopMaps[a.trip_id] || [];
      const bStops = tripStopMaps[b.trip_id] || [];
      let aTime = aStops[0]?.departure_time || "99:99:99";
      let bTime = bStops[0]?.departure_time || "99:99:99";
      if (String(aTime).match(/^\d:/)) aTime = "0" + aTime;
      if (String(bTime).match(/^\d:/)) bTime = "0" + bTime;
      return timeToMinutes(aTime) - timeToMinutes(bTime);
    });
  }
  
  // 1. Znajdź most frequent STATION (merged stop aware)
  const stationCounts = new Map();
  
  trips.forEach(trip => {
    const stops = tripStopMaps[trip.trip_id] || [];
    stops.forEach(s => {
      // getStationId zwraca parent_station || stop_id (merguje przystanki!)
      const stationId = getStationId(s.stop_id, stopsIndex);
      stationCounts.set(stationId, (stationCounts.get(stationId) || 0) + 1);
    });
  });
  
  // Znajdź most frequent station
  let maxCount = 0;
  let anchorStationId = null;
  stationCounts.forEach((count, stId) => {
    if (count > maxCount) {
      maxCount = count;
      anchorStationId = stId;
    }
  });
  
  if (!anchorStationId) {
    // Fallback: chronological
    return trips.sort((a, b) => {
      const aStops = tripStopMaps[a.trip_id] || [];
      const bStops = tripStopMaps[b.trip_id] || [];
      let aTime = aStops[0]?.departure_time || "99:99:99";
      let bTime = bStops[0]?.departure_time || "99:99:99";
      if (String(aTime).match(/^\d:/)) aTime = "0" + aTime;
      if (String(bTime).match(/^\d:/)) bTime = "0" + bTime;
      return timeToMinutes(aTime) - timeToMinutes(bTime);
    });
  }
  
  // 2. Znajdź wszystkie stop_ids dla anchor station (wszystkie perony, etc.)
  const anchorStopIds = [];
  Object.values(stopsIndex).forEach(stop => {
    if (getStationId(stop.stop_id, stopsIndex) === anchorStationId) {
      anchorStopIds.push(stop.stop_id);
    }
  });
  
  // 3. Podziel tripy na core (przez anchor) i non-core (bez anchor)
  const coreTrips = [];
  const nonCoreTrips = [];
  
  trips.forEach(trip => {
    const stops = tripStopMaps[trip.trip_id] || [];
    const hasAnchor = stops.some(s => anchorStopIds.includes(s.stop_id));
    
    if (hasAnchor) {
      coreTrips.push(trip);
    } else {
      nonCoreTrips.push(trip);
    }
  });
  
  // 4. Zbierz wszystkie stop_ids z core trips (wspólne przystanki)
  const coreStopIds = new Set();
  coreTrips.forEach(trip => {
    const stops = tripStopMaps[trip.trip_id] || [];
    stops.forEach(s => {
      coreStopIds.add(s.stop_id);
    });
  });
  
  // 5. Sort core trips by anchorTime (ascending)
  const coreData = coreTrips.map(trip => {
    const stops = tripStopMaps[trip.trip_id] || [];
    
    let anchorTime = null;
    for (let i = 0; i < stops.length; i++) {
      if (anchorStopIds.includes(stops[i].stop_id)) {
        anchorTime = stops[i].departure_time || stops[i].arrival_time;
        break;
      }
    }
    
    // Normalize time
    if (anchorTime && String(anchorTime).match(/^\d:/)) {
      anchorTime = "0" + anchorTime;
    }
    
    if (!anchorTime) {
      anchorTime = "99:99:99";
    }
    
    return {
      trip,
      anchorTime,
      totalStops: stops.length
    };
  });
  
  // Sort core trips by anchor time
  coreData.sort((a, b) => {
    const timeDiff = timeToMinutes(a.anchorTime) - timeToMinutes(b.anchorTime);
    if (timeDiff !== 0) return timeDiff;
    return b.totalStops - a.totalStops;
  });
  
  // 6. Inject non-core trips into sorted core list chronologically
  // For each non-core trip, find insertion point based on first common stop time
  const result = [...coreData.map(cd => cd.trip)]; // Start with sorted core trips
  
  nonCoreTrips.forEach(nonCoreTrip => {
    const nonCoreStops = tripStopMaps[nonCoreTrip.trip_id] || [];
    
    // Find first stop that exists in core trips
    let insertionTime = null;
    let commonStopId = null;
    for (let i = 0; i < nonCoreStops.length; i++) {
      if (coreStopIds.has(nonCoreStops[i].stop_id)) {
        insertionTime = nonCoreStops[i].departure_time || nonCoreStops[i].arrival_time;
        commonStopId = nonCoreStops[i].stop_id;
        break;
      }
    }
    
    // Normalize time
    if (insertionTime && String(insertionTime).match(/^\d:/)) {
      insertionTime = "0" + insertionTime;
    }
    
    // Fallback: if no common stop, use first stop time
    if (!insertionTime) {
      insertionTime = nonCoreStops[0]?.departure_time || "99:99:99";
      if (String(insertionTime).match(/^\d:/)) {
        insertionTime = "0" + insertionTime;
      }
    }
    
    // Find insertion point: compare with core trips' time at the SAME stop (or anchor if not present)
    let insertIdx = result.length; // Default: append at end
    
    for (let i = 0; i < result.length; i++) {
      const coreTrip = result[i];
      const coreStops = tripStopMaps[coreTrip.trip_id] || [];
      
      // Find core trip's time at the common stop (if it has it)
      let coreTimeAtCommon = null;
      if (commonStopId) {
        const coreStop = coreStops.find(s => s.stop_id === commonStopId);
        if (coreStop) {
          coreTimeAtCommon = coreStop.departure_time || coreStop.arrival_time;
          if (String(coreTimeAtCommon).match(/^\d:/)) {
            coreTimeAtCommon = "0" + coreTimeAtCommon;
          }
        }
      }
      
      // If core trip doesn't have the common stop, use its anchor time as fallback
      if (!coreTimeAtCommon) {
        // Find this core trip's anchor time
        for (let j = 0; j < coreStops.length; j++) {
          if (anchorStopIds.includes(coreStops[j].stop_id)) {
            coreTimeAtCommon = coreStops[j].departure_time || coreStops[j].arrival_time;
            if (String(coreTimeAtCommon).match(/^\d:/)) {
              coreTimeAtCommon = "0" + coreTimeAtCommon;
            }
            break;
          }
        }
      }
      
      // Insert before this core trip if non-core comes earlier
      if (coreTimeAtCommon && timeToMinutes(insertionTime) < timeToMinutes(coreTimeAtCommon)) {
        insertIdx = i;
        break;
      }
    }
    
    // Insert at found position
    result.splice(insertIdx, 0, nonCoreTrip);
  });
  
  return result;
}

/**
 * Configuration for adjacent-swaps column ordering algorithm
 * 
 * Parameters:
 * - voteThreshold: minimum number of row-votes required to swap a pair (default: 4)
 * - marginMinutes: time difference margin to avoid swapping on jitter (default: 2)
 * - maxPasses: maximum number of bubble-sort passes to limit runtime (default: 8)
 */
const adjacentSwapOrderConfig = {
  voteThreshold: 4,
  marginMinutes: 2,
  maxPasses: 8
};

/**
 * Adjacent-swaps column ordering algorithm
 * 
 * Performs local corrections on the trips array based on row-wise time comparisons
 * across visible passenger rows only. Unlike global pairwise ranking, this uses
 * a bubble-sort approach with voting:
 * - Compare adjacent pairs across multiple passes
 * - For each pair, count row votes favoring a swap (left time > right time + margin)
 * - If votesSwap >= voteThreshold, swap the pair
 * - Repeat for maxPasses iterations to allow corrections to propagate
 * 
 * Benefits:
 * - Produces locally monotone ordering (minimizes adjacent inversions)
 * - Deterministic and stable with proper parameter tuning
 * - Lower complexity than global pairwise: O(n·rows·passes) vs O(n²·rows)
 * - Works well for routes with mostly consistent trip progression
 * 
 * @param {Array} trips - Array of trip objects in current initial order
 * @param {Array} tripMappings - Array of mapping objects [tripIdx][rowIdx] = stopTime
 * @param {Array} visiblePassengerRowIndices - Row indices to consider (exclude tail rows)
 * @param {Object} params - { voteThreshold, marginMinutes, maxPasses }
 * @returns {Array} Reordered trips array
 */
function adjacentSwapOrder(trips, tripMappings, visiblePassengerRowIndices, params) {
  if (!trips || trips.length <= 1) return trips;
  
  const { voteThreshold, marginMinutes, maxPasses } = params;
  
  // Work with copies to avoid mutating inputs
  const orderedTrips = trips.slice();
  const orderedMappings = tripMappings.slice();
  
  // Perform multiple passes of adjacent comparisons
  for (let pass = 0; pass < maxPasses; pass++) {
    let swapped = false;
    
    // Compare each adjacent pair
    for (let i = 0; i < orderedTrips.length - 1; i++) {
      let votesSwap = 0;
      let votesKeep = 0;
      
      // Count votes across visible passenger rows
      for (const rowIdx of visiblePassengerRowIndices) {
        const stopL = orderedMappings[i][rowIdx];
        const stopR = orderedMappings[i + 1][rowIdx];
        
        // Skip if either trip doesn't stop at this row
        if (!stopL || !stopR) continue;
        
        const timeL = stopL.departure_time || stopL.arrival_time;
        const timeR = stopR.departure_time || stopR.arrival_time;
        
        // Skip if either time is missing
        if (!timeL || !timeR) continue;
        
        const minutesL = timeToMinutes(timeL);
        const minutesR = timeToMinutes(timeR);
        
        // Vote to swap if left is significantly later than right
        if (minutesL > minutesR + marginMinutes) {
          votesSwap++;
        } else if (minutesR > minutesL + marginMinutes) {
          votesKeep++;
        }
        // Within margin: no vote
      }
      
      // Swap if we have enough votes
      if (votesSwap >= voteThreshold) {
        // Swap trips
        [orderedTrips[i], orderedTrips[i + 1]] = [orderedTrips[i + 1], orderedTrips[i]];
        // Swap corresponding mappings to stay in sync
        [orderedMappings[i], orderedMappings[i + 1]] = [orderedMappings[i + 1], orderedMappings[i]];
        swapped = true;
      }
    }
    
    // Early exit if no swaps were made in this pass
    if (!swapped) break;
  }
  
  return orderedTrips;
}

/**
 * Find the most common trip pattern (sequence of stops) for a given stop.
 * Used to identify the typical route variant that serves a stop.
 * 
 * @param {Array} trips - List of trip objects
 * @param {Object} stopTimesIndex - Map of trip_id -> stopTimes array
 * @param {string} stopId - The stop ID to analyze
 * @param {Array} activeServices - List of active service IDs
 * @returns {Object|null} Object with tripId, stopIds array, and frequency count
 */
function findMostFrequentTripPattern(trips, stopTimesIndex, stopId, activeServices) {
  const patternCounts = new Map(); // klucz: "stop1,stop2,stop3...", wartość: count
  const patternToTrip = new Map(); // mapowanie pattern → przykładowy trip_id
  
  trips.forEach(trip => {
    if (!activeServices.includes(trip.service_id)) return;
    
    const stopTimes = stopTimesIndex[trip.trip_id] || [];
    // Sprawdź czy trip przechodzi przez nasz przystanek
    if (!stopTimes.some(st => st.stop_id === stopId)) return;
    
    // Zbuduj "sygnaturę" tripu (sekwencja stop_id)
    const sorted = [...stopTimes].sort((a, b) => 
      parseInt(a.stop_sequence || '0') - parseInt(b.stop_sequence || '0')
    );
    const pattern = sorted.map(st => st.stop_id).join(',');
    
    patternCounts.set(pattern, (patternCounts.get(pattern) || 0) + 1);
    if (!patternToTrip.has(pattern)) {
      patternToTrip.set(pattern, trip.trip_id);
    }
  });
  
  // Znajdź pattern z największą liczbą wystąpień
  let maxCount = 0;
  let mostFrequentPattern = null;
  
  patternCounts.forEach((count, pattern) => {
    if (count > maxCount) {
      maxCount = count;
      mostFrequentPattern = pattern;
    }
  });
  
  if (!mostFrequentPattern) return null;
  
  const representativeTripId = patternToTrip.get(mostFrequentPattern);
  return {
    tripId: representativeTripId,
    stopIds: mostFrequentPattern.split(','),
    frequency: maxCount
  };
}

// ═══════════════════════════════════════════════════════════════
// 8. DIRECTION & HEADSIGN LOGIC
// ═══════════════════════════════════════════════════════════════
function getAvailableDirections() {
  if (!state.selectedRoute || !state.gtfsData) return [];

  let routeIds = [state.selectedRoute.route_id];
  if (state.selectedRouteGroup && Array.isArray(state.selectedRouteGroup.members)) {
    routeIds = state.selectedRouteGroup.members
      .map(r => r.route_id)
      .filter(Boolean);
  }

  let routeTripsAll = [];
  routeIds.forEach(rid => {
    const arr = state.gtfsData.tripsIndex[rid] || [];
    routeTripsAll = routeTripsAll.concat(arr);
  });

  const dirs = Object.create(null);
  for (const t of routeTripsAll) {
    const dirId = String(t.direction_id === undefined || t.direction_id === null ? '0' : t.direction_id);
    if (!dirs[dirId]) dirs[dirId] = { id: dirId, rows: 0, tripIds: new Set(), byHeadsign: Object.create(null), trips: [] };
    dirs[dirId].rows++;
    if (t.trip_id) dirs[dirId].tripIds.add(t.trip_id);
    const hs = (t.trip_headsign || '').toString().trim();
    if (hs) dirs[dirId].byHeadsign[hs] = (dirs[dirId].byHeadsign[hs] || 0) + 1;
    dirs[dirId].trips.push(t);
  }

  const perDir = Object.keys(dirs).map(id => {
    const info = dirs[id];
    const headsignEntries = Object.entries(info.byHeadsign).sort((a,b) => b[1] - a[1]);
    const top1Count = headsignEntries.length ? headsignEntries[0][1] : 0;
    const top1Label = headsignEntries.length ? headsignEntries[0][0] : '';
    const top2Count = headsignEntries.length > 1 ? headsignEntries[1][1] : 0;
    const top2Label = headsignEntries.length > 1 ? headsignEntries[1][0] : '';

    const commonHeadsign = headsignEntries.length ? headsignEntries[0][0] : '';
    let termini = '';
    let bestStops = null, bestLen = 0;
    for (const t of info.trips) {
      const sts = (state.gtfsData.stopTimesIndex && state.gtfsData.stopTimesIndex[t.trip_id]) || [];
      if (sts.length > bestLen) { bestLen = sts.length; bestStops = sts; }
    }
    if (bestStops && bestStops.length > 0) {
      const first = state.gtfsData.stopsIndex[bestStops[0].stop_id];
      const last  = state.gtfsData.stopsIndex[bestStops[bestStops.length - 1].stop_id];
      const firstName = first?.stop_name || bestStops[0].stop_id;
      const lastName  = last?.stop_name  || bestStops[bestStops.length - 1].stop_id;
      termini = (firstName && lastName && firstName !== lastName) ? `${firstName} – ${lastName}` : (lastName || firstName || '');
    }
    const fullName = commonHeadsign || termini || `Direction ${id}`;
    const score = (top1Count || 0) * 3 + (info.rows || 0);

    return {
      dir: id,
      rows: info.rows,
      distinctTripIds: info.tripIds.size,
      top1Count,
      top1Label,
      top2Count,
      top2Label,
      fullName,
      score,
      trips: info.trips
    };
  });

  perDir.sort((a,b) => (b.top1Count - a.top1Count) || (b.rows - a.rows));
  const heuristicResult = applyDirectionHeuristic(perDir, 1, 0.30);
  const labelsMap = heuristicResult.labels || {};

  const result = perDir.map((d, idx) => {
    const l = labelsMap[d.dir];
    const displayName = (l && l.display) ? l.display : (d.top1Label || d.fullName || d.dir);
    const safeDisplay = (displayName && String(displayName).trim()) ? displayName : (d.fullName || d.top1Label || d.dir);
    return { id: d.dir, name: safeDisplay, fullName: d.fullName, score: d.score };
  });

  return result;
}

function applyDirectionHeuristic(perDir, absDiff = 1, relRatio = 0.30) {
  const num = v => (typeof v === 'number' && !Number.isNaN(v)) ? v : 0;
  function closeEnough(x, y, absD, relR) {
    x = num(x); y = num(y);
    const diff = Math.abs(x - y);
    if (diff <= absD) return true;
    const denom = Math.max(Math.abs(x), Math.abs(y), 1);
    return (diff / denom) <= relR;
  }
  const list = Array.isArray(perDir) ? perDir.slice() : [];
  list.sort((a,b) => num(b.top1Count) - num(a.top1Count));
  const labels = {};
  const reason = { text: '', matched: null };
  if (list.length === 0) {
    reason.text = 'no directions';
    reason.matched = 'none';
    return { labels, reason };
  }
  if (list.length === 1) {
    const d = list[0];
    labels[d.dir] = { display: d.top1Label || '', mode: 'single' };
    reason.text = 'single direction';
    reason.matched = 'single';
    return { labels, reason };
  }
  const A = list[0];
  const B = list[1];
  const A_top1 = num(A.top1Count);
  const B_top1 = num(B.top1Count);
  const A_top2sum = A_top1 + num(A.top2Count);
  const B_top2sum = B_top1 + num(B.top2Count);
  if (closeEnough(A_top1, B_top1, absDiff, relRatio)) {
    labels[A.dir] = { display: A.top1Label || '', mode: 'top1-equal' };
    labels[B.dir] = { display: B.top1Label || '', mode: 'top1-equal' };
    reason.text = 'top1 equal';
    reason.matched = 'top1-equal';
    return { labels, reason };
  }
  function combinedLabel(d) {
    const left = d.top1Label || '';
    const right = d.top2Label || '';
    if (!left && !right) return '';
    if (!right) return left;
    if (!left) return right;
    return `${left} / ${right}`;
  }
  if (closeEnough(B_top2sum, A_top1, absDiff, relRatio)) {
    labels[A.dir] = { display: A.top1Label || '', mode: 'top1' };
    labels[B.dir] = { display: combinedLabel(B), mode: 'B_top2≈A_top1' };
    reason.text = 'B top2sum ≈ A top1';
    reason.matched = 'B_top2≈A_top1';
    return { labels, reason };
  }
  if (closeEnough(A_top2sum, B_top1, absDiff, relRatio)) {
    labels[A.dir] = { display: combinedLabel(A), mode: 'A_top2≈B_top1' };
    labels[B.dir] = { display: B.top1Label || '', mode: 'top1' };
    reason.text = 'A top2sum ≈ B top1';
    reason.matched = 'A_top2≈B_top1';
    return { labels, reason };
  }
  labels[A.dir] = { display: A.top1Label || '', mode: 'top1' };
  labels[B.dir] = { display: B.top1Label || '', mode: 'top1' };
  reason.text = 'default top1';
  reason.matched = 'default';
  return { labels, reason };
}

// ═══════════════════════════════════════════════════════════════
// 9. MAP RENDERING
// ═══════════════════════════════════════════════════════════════
    // small utilities consolidated
    function resetMap() {
      if (window.leafletMap) {
        try { window.leafletMap.remove(); } catch(e) {}
        window.leafletMap = null;
        window.leafletFeatureGroup = null;
      }
    }

    function ensureMap(containerId = 'map-container', center=[51.94,13.88], zoom=11) {
      const mapContainer = $(containerId);
      if (!mapContainer) return null;
      if (!window.leafletMap) {
        mapContainer.innerHTML = '';
        const map = window.L.map(mapContainer).setView(center, zoom);
        window.L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', { attribution:'© OpenStreetMap contributors', maxZoom:19 }).addTo(map);
        window.leafletMap = map;
        window.leafletFeatureGroup = window.L.featureGroup().addTo(map);
      }
      return window.leafletMap;
    }

async function generateLineGeometry(stopDetails, routeType) {
  // Generate straight line route from stops
  if (!Array.isArray(stopDetails) || stopDetails.length < 2) return [];
  
  const coordinates = stopDetails
    .map(s => [parseFloat(s.lat || s.stop_lat), parseFloat(s.lon || s.stop_lon)])
    .filter(([lat, lon]) => !isNaN(lat) && !isNaN(lon));
  
  return coordinates;
}

async function generateHybridLineGeometry(stops, shapeId, routeType) {
  if (!stops || stops.length < 2) return [];
  
  const shapesIndex = state.gtfsData?.shapesIndex;
  
  // If no shapes.txt, use straight lines
  if (!shapeId || !shapesIndex || !shapesIndex[shapeId]) {
    return await generateLineGeometry(stops, routeType);
  }
  
  const shapePoints = shapesIndex[shapeId];
  
  // Validate shape coverage
  const coverage = calculateShapeCoverage(stops, shapePoints);
  
  // If good coverage (>70%), use hybrid approach
  if (coverage.percentage >= 0.7) {
    return fillShapeGaps(stops, shapePoints, coverage.nearbyStops);
  }
  
  // Poor coverage - use straight lines
  return await generateLineGeometry(stops, routeType);
}

async function updateMap() {
  const mapContainer = $('map-container');
  if (!mapContainer || !state.selectedRoute) return;
  
  const variantsData = state._lastVariants || computeVariantsForRoute();

  // trips z całej grupy route_id (jeśli jest grupa)
  let routeIds = [state.selectedRoute.route_id];
  if (state.selectedRouteGroup && Array.isArray(state.selectedRouteGroup.members)) {
    routeIds = state.selectedRouteGroup.members
      .map(r => r.route_id)
      .filter(Boolean);
  }

  let routeTripsAll = [];
  routeIds.forEach(rid => {
    const arr = state.gtfsData.tripsIndex[rid] || [];
    routeTripsAll = routeTripsAll.concat(arr);
  });

  // Calculate initial center from route data before initializing map
  let initialCenter = [51.94, 13.88]; // Default fallback
  let initialZoom = 11;
  
  if (variantsData && variantsData.variantDetails) {
    let variantId = state.selectedVariant;
    if (!variantsData.variantDetails[variantId]) {
      const keys = Object.keys(variantsData.variantDetails);
      variantId = keys.length ? keys[0] : variantId;
    }
    const sel = variantsData.variantDetails[variantId];
    if (sel && Array.isArray(sel.stopDetails) && sel.stopDetails.length > 0) {
      // Calculate center from stops
      const validStops = sel.stopDetails.filter(s => s && s.stop_lat && s.stop_lon && !isNaN(parseFloat(s.stop_lat)) && !isNaN(parseFloat(s.stop_lon)));
      if (validStops.length > 0) {
        const lats = validStops.map(s => parseFloat(s.stop_lat));
        const lons = validStops.map(s => parseFloat(s.stop_lon));
        const centerLat = (Math.min(...lats) + Math.max(...lats)) / 2;
        const centerLon = (Math.min(...lons) + Math.max(...lons)) / 2;
        initialCenter = [centerLat, centerLon];
        initialZoom = 13;
      }
    }
  }
  
  ensureMap('map-container', initialCenter, initialZoom);
  const map = window.leafletMap;
  const fg = window.leafletFeatureGroup;
  
  // Wyczyść tylko warstwy
  fg.clearLayers();

  const routeColor = getRouteTypeMeta(state.selectedRoute?.route_type).color || '#3b82f6';
  const routeType = state.selectedRoute.route_type;
  
const addMarker = (lat, lon, name, color) => {
  if (isNaN(lat) || isNaN(lon)) return;
  fg.addLayer(window.L.circleMarker([lat, lon], { 
      radius:6, 
      fillColor: color || '#3b82f6', 
      color:'#fff', 
      weight:2, 
      fillOpacity:0.8 
    }).bindPopup(name || ''));
  };
  
  let drawnVariantCoords = [];
  if (variantsData && variantsData.variantDetails) {
    let variantId = state.selectedVariant;
    if (!variantsData.variantDetails[variantId]) {
      const keys = Object.keys(variantsData.variantDetails);
      variantId = keys.length ? keys[0] : variantId;
    }
const sel = variantsData.variantDetails[variantId];
if (sel && Array.isArray(sel.stopDetails) && sel.stopDetails.length > 0) {
  let lineGeometry = null;
  
  // ===== HIERARCHY FOR ROUTE DRAWING =====
  // 1. Try shapes.txt (best quality - from GTFS)
  if (state.gtfsData. shapesIndex && Object.keys(state.gtfsData.shapesIndex).length > 0) {
    const variantTrips = variantsData.trips.filter(t => variantsData.tripToVariant[t.trip_id] === variantId);
    
    if (variantTrips. length > 0) {
      const shapeId = variantTrips[0].shape_id;
      
      if (shapeId && state.gtfsData. shapesIndex[shapeId]) {
        lineGeometry = state.gtfsData.shapesIndex[shapeId];
      }
    }
  }
  
  // 2. Final fallback: Simple straight lines between stops
  if (!lineGeometry) {
    lineGeometry = sel.stopDetails
      .map(s => [parseFloat(s.stop_lat), parseFloat(s.stop_lon)])
      .filter(([lat, lon]) => !isNaN(lat) && !isNaN(lon));
  }

  if (lineGeometry && lineGeometry.length > 1) {
    fg.addLayer(window.L.polyline(lineGeometry, { 
      color: routeColor, 
      weight: 5,
      opacity: 0.9,
      smoothFactor: 0.5 
    }));
  }

  // Dodaj markery przystanków...
      sel.stopDetails.forEach(s => {
        if (s && s.stop_lat && s.stop_lon) {
          const lat = parseFloat(s.stop_lat), lon = parseFloat(s.stop_lon);
          if (!isNaN(lat) && !isNaN(lon)) {
            addMarker(lat, lon, s.stop_name, routeColor);
            drawnVariantCoords.push([lat, lon]);
          }
        }
      });
    }
  }
  
  // Fallback jeśli nie ma wariantu
  if (drawnVariantCoords.length < 2) {
    const allStopIds = new Set();
    routeTripsAll.forEach(trip => {
      const sts = state.gtfsData.stopTimesIndex[trip.trip_id] || [];
      sts.forEach(st => { if (st && st.stop_id) allStopIds.add(st.stop_id); });
    });
    const allCoords = [];
    allStopIds.forEach(stopId => {
      const stop = state.gtfsData.stopsIndex[stopId];
      if (stop && stop.stop_lat && stop.stop_lon) {
        const lat = parseFloat(stop.stop_lat), lon = parseFloat(stop.stop_lon);
        if (!isNaN(lat) && !isNaN(lon)) {
          addMarker(lat, lon, stop.stop_name, routeColor);
          allCoords.push([lat, lon]);
        }
      }
    });
    if (allCoords.length > 1) fg.addLayer(window.L.polyline(allCoords, { color:'#9ca3af', weight:2, opacity:0.6 }));
  }
  
  if (fg.getLayers().length === 0) {
    map.remove();
    resetMap();
    mapContainer.innerHTML = '<div class="p-4 text-gray-500">No map data available for this route</div>';
    return;
  }
  
  let bounds = fg.getBounds();
  if (!bounds || !bounds.isValid || (bounds.getNorthEast && bounds.getSouthWest &&
      Math.abs(bounds.getNorthEast().lat - bounds.getSouthWest().lat) < 0.0005 &&
      Math.abs(bounds.getNorthEast().lng - bounds.getSouthWest().lng) < 0.0005)) {
    const firstLayer = fg.getLayers()[0];
    let p = null;
    if (firstLayer && firstLayer.getLatLng) p = firstLayer.getLatLng();
    if (p) {
      const delta = 0.005;
      bounds = window.L.latLngBounds([[p.lat - delta, p.lng - delta], [p.lat + delta, p.lng + delta]]);
    }
  }
  
  try {
    if (bounds && bounds.isValid && !(bounds.getNorthEast().equals(bounds.getSouthWest()))) {
      map.fitBounds(bounds, { padding: [20,20], maxZoom: 18 });
    } else {
      const layer = fg.getLayers()[0];
      if (layer && layer.getLatLng) map.setView(layer.getLatLng(), 13);
    }
  } catch (err) {
    // Ignore map fit errors - they don't prevent map from displaying
  }
}

async function renderStopDetailMap(stopId, selectedDate, filteredRouteIds = []) {
  const mapContainer = $('stop-detail-map');
  if (!mapContainer) return;
  
  const stop = state.gtfsData.stopsIndex[stopId];
  if (!stop || !stop.stop_lat || !stop.stop_lon) {
    mapContainer.innerHTML = '<div class="p-4 text-gray-500">Brak danych lokalizacyjnych dla przystanku</div>';
    return;
  }
  
  const lat = parseFloat(stop.stop_lat);
  const lon = parseFloat(stop.stop_lon);
  if (isNaN(lat) || isNaN(lon)) {
    mapContainer.innerHTML = '<div class="p-4 text-gray-500">Nieprawidłowe współrzędne przystanku</div>';
    return;
  }
  
  // Zbierz dane tras
  const result = collectRoutesForStop(stopId, selectedDate, []);
  
  // No limit - removed tooMany check
  const routesData = result.routes || [];
  
  // Initialize map only once
  if (!state.stopDetailMapInitialized) {
    mapContainer.innerHTML = '';
    const map = window.L.map(mapContainer).setView([lat, lon], 14);
    window.L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
      attribution: '© OpenStreetMap contributors',
      maxZoom: 19
    }).addTo(map);
    
    state.stopDetailMapInstance = map;
    state.stopDetailMapLayers = {};
    
    const allBounds = [];
    
    // Create layers for each route
    for (const routeData of routesData) {
      const { route, stops, color, direction, shapeId } = routeData;
      const layerKey = `${route.route_id}_${direction}`;
      
      // Create a feature group for this route
      const layer = window.L.featureGroup();
      
      // Draw main route stops (core + branch, excluding branch_start and branch_end)
      const mainRouteStops = stops.filter(s => s.type === 'core' || s.type === 'branch');
      
      if (mainRouteStops.length > 1) {
        let lineGeometry = null;
        
        // Use hybrid approach: shapes.txt + gap filling, or straight lines
        lineGeometry = await generateHybridLineGeometry(mainRouteStops, shapeId, route.route_type);

        // Draw polyline if we have at least 2 points
        if (Array.isArray(lineGeometry) && lineGeometry.length > 1) {
          window.L.polyline(lineGeometry, {
            color: color,
            weight: 3,
            opacity: 0.7,
            smoothFactor: 0.5
          }).addTo(layer);
        }
      }

      // Add main route stops as small markers and collect bounds
      mainRouteStops.forEach(s => {
        if (!s || isNaN(parseFloat(s.lat)) || isNaN(parseFloat(s.lon))) return;
        const sLat = parseFloat(s.lat);
        const sLon = parseFloat(s.lon);
        window.L.circleMarker([sLat, sLon], {
          radius: 3,
          fillColor: color,
          color: '#fff',
          weight: 1,
          fillOpacity: 0.8
        }).addTo(layer).bindPopup(s.name);

        allBounds.push([sLat, sLon]);
      });
      
      // Store layer and add to map
      state.stopDetailMapLayers[layerKey] = layer;
      layer.addTo(map);
    }
    
    // Add main stop (selected) as larger marker
    window.L.circleMarker([lat, lon], {
      radius: 8,
      fillColor: '#ef4444',
      color: '#fff',
      weight: 3,
      fillOpacity: 1
    }).addTo(map).bindPopup(`<b>${stop.stop_name}</b>`).openPopup();
    
    allBounds.push([lat, lon]);
    
    // Fit view to all points once
    if (allBounds.length > 0) {
      map.fitBounds(allBounds, { padding: [30, 30], maxZoom: 16 });
    }
    
    state.stopDetailMapInitialized = true;
  }
} // << zamknięcie funkcji renderującej mapę szczegółową

function filterStopDetailMapLayers(filteredRouteIds = []) {
  if (!state.stopDetailMapInstance || !state.stopDetailMapInitialized) {
    return;
  }

  const filterIds = (filteredRouteIds || []).map(String);
  const map = state.stopDetailMapInstance;

  Object.entries(state.stopDetailMapLayers).forEach(([layerKey, layer]) => {
    const routeId = layerKey.split('_')[0]; // Extract route_id from "route_id_direction"
    const shouldShow = filterIds.length === 0 || filterIds.includes(routeId);

    if (shouldShow) {
      if (!map.hasLayer(layer)) {
        layer.addTo(map);
      }
    } else {
      if (map.hasLayer(layer)) {
        map.removeLayer(layer);
      }
    }
  });
}

// ═══════════════════════════════════════════════════════════════
// 10. SHARED UI HELPERS
// ═══════════════════════════════════════════════════════════════
    function findRouteById(routeId) {
      return (state.gtfsData && state.gtfsData.routes || []).find(r => String(r.route_id) === String(routeId));
    }

    function routeBadgeHtml(route, meta) {
      const label = escapeHtml(route.route_short_name || route.route_id || '');
      const color = (meta && meta.color) || '#3b82f6';
      return `<a href="#" class="route-link" data-route-id="${escapeHtml(route.route_id)}" style="text-decoration:none;">
        <span
          style="
            display:inline-block;
            padding:2px 8px;
            font-weight:600;
            border-radius:4px;
            background:${color}20;
            color:${color};
            border-left:3px solid ${color};
          "
        >
          ${label}
        </span>
      </a>`;
    }

// ═══════════════════════════════════════════════════════════════
// 11. UI RENDERING - ROUTES VIEW
// ═══════════════════════════════════════════════════════════════
function renderRouteTable() {
  const container = $('routes-tbody');
  if (!container || !state.gtfsData) return;
  container.innerHTML = '';

  const logicalRoutes = state.gtfsData.logicalRoutes || [];
  const baseRoutes = (state.gtfsData.routes || []).slice();

  // helper: reprezentant grupy logicznej
  function reprOf(group) {
    return (group && group.members && group.members[0]) || null;
  }

// Twoje wyświetlanie (np. w labelOf)
function labelOf(group) {
    // Bierz od reprezentanta (czyli pierwszego route z grupy)
    const r = reprOf(group);
    if (!r) return group?.route_short_name || '';
    return r.route_short_name || r.route_id || group.route_short_name || '';
}

  // sortowanie logicznych grup po numerze linii
  function sortGroupsByRouteId(arr) {
    return arr.slice().sort((a, b) => {
      const la = String(labelOf(a) || '').trim();
      const lb = String(labelOf(b) || '').trim();
      return la.localeCompare(lb, undefined, { numeric: true, sensitivity: 'base' });
    });
  }

  // sortowanie surowych routes po route_short_name / route_id
  function sortRoutesById(routes) {
    return routes.slice().sort((a, b) => {
      const la = String(a.route_short_name || a.route_id || '').trim();
      const lb = String(b.route_short_name || b.route_id || '').trim();
      return la.localeCompare(lb, undefined, { numeric: true, sensitivity: 'base' });
    });
  }

  // === TRYB 1: LOGICAL (DOMYŚLNY) – jedna siatka z logicznymi liniami ===
  if (state.routeGroupMode === 'logical') {
    if (!logicalRoutes.length) return;

    const grid = document.createElement('div');
    grid.className = 'routes-grid';

    sortGroupsByRouteId(logicalRoutes).forEach(group => {
      const repr = reprOf(group);
      if (!repr) return;
      const metaRt = getRouteTypeMeta(repr.route_type);
      const btn = document.createElement('button');
      btn.className = 'route-card';
      btn.style.borderLeft = `6px solid ${metaRt.color || '#e6eefb'}`;

const label = labelOf(group);

btn.innerHTML = `
  <div style="display:flex;flex-direction:column;align-items:center;justify-content:center;">
    <div style="font-weight:700;">${escapeHtml(label)}</div>
  </div>
`;

      btn.onclick = () => {
        state.selectedRouteGroup = group;
        selectRoute(repr);
      };

      grid.appendChild(btn);
    });

    container.appendChild(grid);
    return;
  }

  // === TRYB 2: SERVICE_TYPE – logiczne linie zgrupowane wg canonical_type ===
  if (state.routeGroupMode === 'service_type') {
    if (!logicalRoutes.length) return;

    const groupsByCat = new Map();

    logicalRoutes.forEach(group => {
      const repr = reprOf(group);
      const cat = repr ? (collectRouteType(repr).canonical || 'other') : 'other';
      if (!groupsByCat.has(cat)) groupsByCat.set(cat, []);
      groupsByCat.get(cat).push(group);
    });

    const catKeys = Array.from(groupsByCat.keys()).sort((a, b) => {
      const oa = (CANONICAL_CATEGORIES[a] && CANONICAL_CATEGORIES[a].order) || 999;
      const ob = (CANONICAL_CATEGORIES[b] && CANONICAL_CATEGORIES[b].order) || 999;
      if (oa !== ob) return oa - ob;
      const la = (CANONICAL_CATEGORIES[a] && CANONICAL_CATEGORIES[a].label) || String(a);
      const lb = (CANONICAL_CATEGORIES[b] && CANONICAL_CATEGORIES[b].label) || String(b);
      return la.localeCompare(lb, undefined, { sensitivity: 'base' });
    });

    catKeys.forEach(cat => {
      const titleEl = document.createElement('div');
      titleEl.className = 'agency-title';
      titleEl.textContent = (CANONICAL_CATEGORIES[cat] && CANONICAL_CATEGORIES[cat].label) || cat || 'Other';
      container.appendChild(titleEl);

      const grid = document.createElement('div');
      grid.className = 'routes-grid';

      const list = sortGroupsByRouteId(groupsByCat.get(cat) || []);
      list.forEach(group => {
        const repr = reprOf(group);
        if (!repr) return;
        const metaRt = getRouteTypeMeta(repr.route_type);
        const btn = document.createElement('button');
        btn.className = 'route-card';
        btn.style.borderLeft = `6px solid ${metaRt.color || '#e6eefb'}`;

const label = labelOf(group);

btn.innerHTML = `
  <div style="display:flex;flex-direction:column;align-items:center;justify-content:center;">
    <div style="font-weight:700;">${escapeHtml(label)}</div>
  </div>
`;

        btn.onclick = () => {
          state.selectedRouteGroup = group;
          selectRoute(repr);
        };

        grid.appendChild(btn);
      });

      grid.style.marginBottom = '28px';
      container.appendChild(grid);
    });

    return;
  }

  // === TRYB 3: AGENCY – logiczne linie zgrupowane wg przewoźnika ===
  if (state.routeGroupMode === 'agency') {
    if (!logicalRoutes.length) return;

    const byAgency = new Map();

    logicalRoutes.forEach(group => {
      const repr = reprOf(group);
      const agencyId = repr?.agency_id || group.agency_id || '';
      const agencyName = agencyId && state.gtfsData.agenciesIndex[agencyId]
        ? (state.gtfsData.agenciesIndex[agencyId].agency_name || agencyId)
        : 'Nieznany przewoźnik';

      if (!byAgency.has(agencyName)) byAgency.set(agencyName, []);
      byAgency.get(agencyName).push(group);
    });

    const agencyKeys = Array.from(byAgency.keys()).sort((a, b) =>
      a.localeCompare(b, undefined, { sensitivity: 'base' })
    );

    agencyKeys.forEach(agencyName => {
      const titleEl = document.createElement('div');
      titleEl.className = 'agency-title';
      titleEl.textContent = agencyName;
      container.appendChild(titleEl);

      const grid = document.createElement('div');
      grid.className = 'routes-grid';

      const list = sortGroupsByRouteId(byAgency.get(agencyName) || []);
      list.forEach(group => {
        const repr = reprOf(group);
        if (!repr) return;
        const metaRt = getRouteTypeMeta(repr.route_type);
        const btn = document.createElement('button');
        btn.className = 'route-card';
        btn.style.borderLeft = `6px solid ${metaRt.color || '#e6eefb'}`;

    const label = labelOf(group);

    btn.innerHTML = `
      <div style="display:flex;flex-direction:column;align-items:center;justify-content:center;">
        <div style="font-weight:700;">${escapeHtml(label)}</div>
      </div>
    `;

        btn.onclick = () => {
          state.selectedRouteGroup = group;
          selectRoute(repr);
        };

        grid.appendChild(btn);
      });

      grid.style.marginBottom = '28px';
      container.appendChild(grid);
    });

    return;
  }

  // === TRYB 4: RAW_ROUTES – awaryjny: każdy rekord routes osobno, sort po numerze ===
  if (state.routeGroupMode === 'raw_routes') {
    const routes = sortRoutesById(baseRoutes);
    const grid = document.createElement('div');
    grid.className = 'routes-grid';

    routes.forEach(route => {
      const btn = document.createElement('button');
      btn.className = 'route-card';
      btn.textContent = route.route_short_name || route.route_id || '';
      const metaRt = getRouteTypeMeta(route.route_type);
      btn.style.borderLeft = `6px solid ${metaRt.color || '#e6eefb'}`;

      btn.onclick = () => {
        state.selectedRouteGroup = null; // w tym trybie świadomie patrzymy na pojedynczy route_id
        selectRoute(route);
      };

      grid.appendChild(btn);
    });

    container.appendChild(grid);
    return;
  }

  // fallback – jeśli coś poszło nie tak, wracamy do logical
  state.routeGroupMode = 'logical';
  renderRouteTable();
}

function selectRoute(route) {
  // Save scroll position before navigating away from ROUTES_LIST
  const container = document.querySelector('#routes-list-container');
  if (container) {
    state.routesListScrollPosition = container.scrollTop || 0;
  }
  
  state.selectedRoute = route;

  // Jeśli bieżąca grupa logiczna NIE zawiera tej trasy, czyścimy grupę
  if (!state.selectedRouteGroup ||
      !(state.selectedRouteGroup.members || []).some(r => r.route_id === route.route_id)) {
    state.selectedRouteGroup = null;
  }

  const routeTrips = state.gtfsData.tripsIndex[route.route_id] || [];
  if (routeTrips.length > 0) {
    state.selectedDirection = [...new Set(routeTrips.map(t => t.direction_id || '0'))][0];
  }

  // Invalidate canonical cache when route changes
  invalidateCanonicalCacheForCurrentSelection();

  resetMap();
  render();
}

// ═══════════════════════════════════════════════════════════════
// 12. UI RENDERING - STOPS VIEW
// ═══════════════════════════════════════════════════════════════
// FAZA 1.2: Search index dla szybszego wyszukiwania

function buildStopsSearchIndex(groupsArray) {
  if (stopsSearchIndex) return stopsSearchIndex;
  
  stopsSearchIndex = groupsArray.map(group => ({
    id: group.id,
    name: group.name,
    searchText: group.name.toLowerCase().trim(), // pre-normalized
    routeCount: group.routeCount,
    stops: group.stops,
    routeSet: group.routeSet
  }));
  
  return stopsSearchIndex;
}

function clearStopsSearchIndex() {
  stopsSearchIndex = null;
}

function searchStopsInIndex(query, groupsArray) {
  if (!query || query.trim() === '') return groupsArray;
  
  const index = buildStopsSearchIndex(groupsArray);
  const lowerQuery = query.toLowerCase().trim();
  
  return index
    .filter(item => item.searchText.includes(lowerQuery))
    .map(item => ({
      id: item.id,
      name: item.name,
      routeCount: item.routeCount,
      stops: item.stops,
      routeSet: item.routeSet
    }));
}

function getOrBuildGroupsArray(stopsData) {
  // Simple hash based on stops count
  const currentHash = stopsData.length + '_' + (stopsData[0]?.stop_id || '');
  
  if (cachedGroupsArray && lastStopsDataHash === currentHash) {
    return cachedGroupsArray;
  }
  
  // Grupuj przystanki według nazwy bazowej (bez numerów)
  const stopGroups = new Map();
  stopsData.forEach(stop => {
    const stopName = stop.stop_name || '';
    const baseName = stopName.replace(/\s+\d+[A-Za-z]?$/, '').trim();
    
    if (!stopGroups.has(baseName)) {
      stopGroups.set(baseName, {
        id: baseName,
        name: baseName,
        stops: [],
        routeSet: new Set()
      });
    }
    
    const group = stopGroups.get(baseName);
    group.stops.push(stop);
    stop.routes.forEach(route => group.routeSet.add(route.route_id));
  });
  
  const groupsArray = Array.from(stopGroups.values()).map(group => ({
    ...group,
    routeCount: group.routeSet.size
  }));
  
  groupsArray.sort((a, b) => a.name.localeCompare(b.name));
  
  cachedGroupsArray = groupsArray;
  lastStopsDataHash = currentHash;
  
  return groupsArray;
}

function measureStopItemHeight() {
  const firstItem = document.querySelector('.stop-group');
  if (firstItem) {
    const height = firstItem.offsetHeight;
    if (height > 0 && height !== state.virtualListItemHeight) {
      state.virtualListItemHeight = height;
    }
  }
}

function renderVirtualStopsList(groupsToRender) {
  const stopsList = $('stops-list');
  if (!stopsList) return;
  
  const container = stopsList.parentElement; // scrollable container
  if (!container) return;
  
  const containerHeight = container.clientHeight || 600;
  const scrollTop = container.scrollTop || 0;
  const itemHeight = state.virtualListItemHeight;
  
  // Calculate visible range with buffer
  const bufferSize = 5;
  const visibleCount = Math.ceil(containerHeight / itemHeight) + bufferSize * 2;
  const startIndex = Math.max(0, Math.floor(scrollTop / itemHeight) - bufferSize);
  const endIndex = Math.min(startIndex + visibleCount, groupsToRender.length);
  
  state.virtualListStartIndex = startIndex;
  
  const visibleGroups = groupsToRender.slice(startIndex, endIndex);
  const totalHeight = groupsToRender.length * itemHeight;
  const offsetY = startIndex * itemHeight;
  
  let html = `<div style="height: ${totalHeight}px;position:relative;">`;
  html += `<div style="position:absolute;top:${offsetY}px;left:0;right:0;">`;
  
  visibleGroups.forEach((group, idx) => {
    const actualIndex = startIndex + idx;
    const isGroupExpanded = state.expandedStopGroup === group.id;
    const pluralForm = group.routeCount === 1 ? 'linia' : 
      (group.routeCount % 10 >= 2 && group.routeCount % 10 <= 4 && (group.routeCount % 100 < 10 || group.routeCount % 100 >= 20)) 
      ? 'linie' : 'linii';
    
    html += `
      <div class="stop-group p-3 border-b hover:bg-blue-50 cursor-pointer ${isGroupExpanded ? 'bg-blue-50' : ''}" 
           data-group-id="${escapeHtml(group.id)}" 
           data-index="${actualIndex}">
        <div class="font-semibold">${escapeHtml(group.name)}</div>
        <div class="text-xs text-gray-600">${group.routeCount} ${pluralForm}</div>
      </div>
    `;
    
    // Expanded stops (non-virtualized for simplicity)
    if (isGroupExpanded) {
      group.stops.forEach(stop => {
        const stopPluralForm = stop.routeCount === 1 ? 'linia' : 
          (stop.routeCount % 10 >= 2 && stop.routeCount % 10 <= 4 && (stop.routeCount % 100 < 10 || stop.routeCount % 100 >= 20)) 
          ? 'linie' : 'linii';
        
        html += `
          <div class="stop-item p-2 pl-6 border-b hover:bg-blue-100 cursor-pointer bg-white" data-stop-id="${stop.stop_id}">
            <div class="font-medium text-sm">${escapeHtml(stop.stop_name)}</div>
            <div class="text-xs text-gray-600">${stop.routeCount} ${stopPluralForm}</div>
          </div>
        `;
      });
    }
  });
  
  html += `</div></div>`;
  stopsList.innerHTML = html;
  
  // Measure height on first render
  if (state.virtualListItemHeight === 68) {
    setTimeout(measureStopItemHeight, 50);
  }
}

function renderStopsView() {
  if (!state.gtfsData || !state.showStopsView) return;
  
  const stopsList = $('stops-list');
  const stopsMap = $('stops-map');
  if (!stopsList || !stopsMap) return;
  
  // Zbierz wszystkie przystanki z liczbą tras
  const stopsData = [];
  const stopToRoutes = new Map();
  
  state.gtfsData.routes.forEach(route => {
    const trips = state.gtfsData.tripsIndex[route.route_id] || [];
    const stopIds = new Set();
    trips.forEach(trip => {
      const stopTimes = state.gtfsData.stopTimesIndex[trip.trip_id] || [];
      stopTimes.forEach(st => stopIds.add(st.stop_id));
    });
    
    stopIds.forEach(stopId => {
      if (!stopToRoutes.has(stopId)) stopToRoutes.set(stopId, []);
      stopToRoutes.get(stopId).push(route);
    });
  });
  
  Object.values(state.gtfsData.stopsIndex).forEach(stop => {
    const routes = stopToRoutes.get(stop.stop_id) || [];
    if (routes.length > 0) {
      stopsData.push({
        ...stop,
        routeCount: routes.length,
        routes: routes
      });
    }
  });
  
  // Sortuj alfabetycznie
  stopsData.sort((a, b) => (a.stop_name || '').localeCompare(b.stop_name || ''));
  
  // FAZA 2.5: Use cached groupsArray
  const groupsArray = getOrBuildGroupsArray(stopsData);
  
  // FAZA 1.3: Use search index instead of direct filtering
  const searchQuery = state.stopsListSearchQuery;
  const filteredGroups = searchStopsInIndex(searchQuery, groupsArray);
  
  // FAZA 2.4: Use virtual list for performance or regular list for small datasets
  const useVirtualList = filteredGroups.length > 100; // Threshold

  if (useVirtualList) {
    renderVirtualStopsList(filteredGroups);
  } else {
    // FAZA 1.5: Implement pagination for better initial load performance
    const groupsPerPage = state.stopsListPageSize;
    const totalGroups = filteredGroups.length;
    const groupsToShow = filteredGroups.slice(0, state.stopsListPage * groupsPerPage);

    // Renderuj listę (bez pola wyszukiwania - jest teraz w nagłówku)
    let html = '';

    groupsToShow.forEach(group => {
      const isExpanded = state.expandedStopGroup === group.id;
      const pluralForm = group.routeCount === 1 ? 'linia' : 
        (group.routeCount % 10 >= 2 && group.routeCount % 10 <= 4 && (group.routeCount % 100 < 10 || group.routeCount % 100 >= 20)) 
        ? 'linie' : 'linii';
      
      // Poziom 1: Grupa przystanków
      html += `
        <div class="stop-group p-3 border-b hover:bg-blue-50 cursor-pointer ${isExpanded ? 'bg-blue-50' : ''}" data-group-id="${escapeHtml(group.id)}">
          <div class="font-semibold">${escapeHtml(group.name)}</div>
          <div class="text-xs text-gray-600">${group.routeCount} ${pluralForm}</div>
        </div>
      `;
      
      // Poziom 2: Konkretne przystanki w grupie (tylko jeśli rozwinięta)
      if (isExpanded) {
        group.stops.forEach(stop => {
          const stopPluralForm = stop.routeCount === 1 ? 'linia' : 
            (stop.routeCount % 10 >= 2 && stop.routeCount % 10 <= 4 && (stop.routeCount % 100 < 10 || stop.routeCount % 100 >= 20)) 
            ? 'linie' : 'linii';
          
          html += `
            <div class="stop-item p-2 pl-6 border-b hover:bg-blue-100 cursor-pointer bg-white" data-stop-id="${stop.stop_id}">
              <div class="font-medium text-sm">${escapeHtml(stop.stop_name)}</div>
              <div class="text-xs text-gray-600">${stop.routeCount} ${stopPluralForm}</div>
            </div>
          `;
        });
      }
    });

    // FAZA 1.5: Add "Load More" button if there are more groups
    if (groupsToShow.length < totalGroups) {
      const remaining = totalGroups - groupsToShow.length;
      html += `
        <div class="p-4 text-center">
          <button id="load-more-stops" class="px-4 py-2 bg-blue-500 text-white rounded hover:bg-blue-600 transition">
            Pokaż więcej (${remaining} pozostało)
          </button>
        </div>
      `;
    }

    stopsList.innerHTML = html;

    // FAZA 1.5: Handle "Load More" button
    const loadMoreBtn = $('load-more-stops');
    if (loadMoreBtn) {
      loadMoreBtn.addEventListener('click', () => {
        state.stopsListPage++;
        renderStopsView();
      });
    }
  }

  // FAZA 2.4: Setup scroll listener for virtual list
  if (useVirtualList) {
    const container = stopsList.parentElement;
    if (container) {
      // Remove old listener if exists
      if (container._virtualScrollHandler) {
        container.removeEventListener('scroll', container._virtualScrollHandler);
      }
      
      const scrollHandler = debounce(() => {
        renderVirtualStopsList(filteredGroups);
      }, 50);
      
      container._virtualScrollHandler = scrollHandler;
      container.addEventListener('scroll', scrollHandler);
    }
  }

  // Obsługa pola wyszukiwania (z nagłówka, nie dynamicznie renderowane)
  const searchInput = $('stops-search-input-header');
  if (searchInput) {
    // Update value to match current state
    searchInput.value = state.stopsListSearchQuery;
    
    // Remove old event listener if exists
    const oldHandler = searchInput._searchHandler;
    if (oldHandler) {
      searchInput.removeEventListener('input', oldHandler);
    }
    
    // FAZA 1.6: Add debounced event listener for better performance
    const debouncedSearch = debounce((value) => {
      state.stopsListSearchQuery = value;
      state.stopsListPage = 1; // FAZA 1.6: Reset pagination on search
      renderStopsView();
    }, 500); // FAZA 1.1: Zwiększone z 300ms do 500ms
    
    const newHandler = (e) => {
      debouncedSearch(e.target.value);
    };
    searchInput._searchHandler = newHandler;
    searchInput.addEventListener('input', newHandler);
  }

  // Inicjalizuj mapę
  stopsMap.innerHTML = '';
  
  // Store reference to map in window for reuse
  if (window.stopsListMap) {
    try {
      window.stopsListMap.remove();
    } catch (e) {}
    window.stopsListMap = null;
  }
  
  // Initialize map immediately (removed setTimeout for better responsiveness)
  if (!stopsMap || stopsMap.offsetParent === null) return;
  
  // Restore map state if returning from STOP_DETAIL
  let initialCenter = [52.23, 21.01];
  let initialZoom = 12;
  
  if (state.stopsListMapState) {
    initialCenter = [state.stopsListMapState.center.lat, state.stopsListMapState.center.lng];
    initialZoom = state.stopsListMapState.zoom;
  }
  
  const map = window.L.map(stopsMap).setView(initialCenter, initialZoom);
  window.stopsListMap = map;
	
    window.L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
      attribution: '© OpenStreetMap contributors',
      maxZoom: 19
    }).addTo(map);
    
    // Create marker cluster group with neutral colors
    const markers = window.L.markerClusterGroup({
      maxClusterRadius: 30,
      spiderfyOnMaxZoom: true,
      showCoverageOnHover: false,
      disableClusteringAtZoom: 17,
      iconCreateFunction: function(cluster) {
        const count = cluster.getChildCount();
        let c = ' marker-cluster-';
        if (count < 10) {
          c += 'small';
        } else if (count < 100) {
          c += 'medium';
        } else {
          c += 'large';
        }
        
        return new window.L.DivIcon({ 
          html: '<div><span>' + count + '</span></div>',
          className: 'marker-cluster marker-cluster-neutral' + c,
          iconSize: new window.L.Point(40, 40)
        });
      }
    });
    
    const bounds = [];
    
    // Always show all stops as markers
    stopsData.forEach(stop => {
      if (!stop.stop_lat || !stop.stop_lon) return;
      const lat = parseFloat(stop.stop_lat);
      const lon = parseFloat(stop.stop_lon);
      if (isNaN(lat) || isNaN(lon)) return;
      
      const marker = window.L.circleMarker([lat, lon], {
        radius: 6,
        fillColor: '#3b82f6',
        color: '#fff',
        weight: 2,
        fillOpacity: 0.8
      });
      
      // Popup behavior depends on whether a group is expanded
      if (state.expandedStopGroup === null) {
        // State 1: Lista pokazuje grupy - popup z klikalnym linkiem
        marker.bindPopup(`
          <a href="#" onclick="event.preventDefault(); 
            state.selectedStop = state.gtfsData.stopsIndex['${stop.stop_id}']; 
            state.stopViewFilteredRoutes = []; 
			state.stopsListMapState = null;
            render(); 
            return false;" 
            style="text-decoration: none; color:inherit;">
            <strong>${escapeHtml(stop.stop_name)}</strong><br>
            ${stop.routeCount} ${stop.routeCount === 1 ? 'linia' : 
              (stop.routeCount % 10 >= 2 && stop.routeCount % 10 <= 4 && (stop.routeCount % 100 < 10 || stop.routeCount % 100 >= 20)) 
              ? 'linie' : 'linii'}
          </a>
        `, { 
          closeButton: false  // Usuń "x"
        });
      } else {
        // State 2: Lista pokazuje przystanki - bezpośrednie przejście do STOP_DETAIL
        marker.on('click', () => {
          state.selectedStop = stop;
          state.stopViewFilteredRoutes = [];
          render();
        });
      }
      
      markers.addLayer(marker);
      bounds.push([lat, lon]);
    });
    
    map.addLayer(markers);
    
    // Center map on expanded group if any
    if (state.expandedStopGroup && !state.stopsListMapState) {
      const expandedGroup = groupsArray.find(g => g.id === state.expandedStopGroup);
      if (expandedGroup && expandedGroup.stops.length > 0) {
        const groupBounds = window.L.latLngBounds();
        expandedGroup.stops.forEach(stop => {
          if (stop.stop_lat && stop.stop_lon) {
            const lat = parseFloat(stop.stop_lat);
            const lon = parseFloat(stop.stop_lon);
            if (!isNaN(lat) && !isNaN(lon)) {
              groupBounds.extend([lat, lon]);
            }
          }
        });
        
        if (groupBounds.isValid()) {
          map.fitBounds(groupBounds, { padding: [50, 50], maxZoom: 16 });
        }
      }
    } else if (bounds.length > 0 && !state.stopsListMapState) {
      map.fitBounds(bounds, { padding: [50, 50], maxZoom: 15 });
    }
  
  // Event delegation for stop groups - toggle expand/collapse + zoom map
  const stopsListContainer = stopsList.parentElement || stopsList;
  
  if (stopsListContainer) {
    // Remove old handler
    if (stopsListContainer._stopGroupHandler) {
      stopsListContainer.removeEventListener('click', stopsListContainer._stopGroupHandler);
    }
    
    const groupHandler = (e) => {
      const stopGroup = e.target.closest('.stop-group');
      if (!stopGroup) return;
      
      e.preventDefault();
      e.stopPropagation();
      
      const groupId = stopGroup.getAttribute('data-group-id');
      const groupsArray = getOrBuildGroupsArray(stopsData);
      const group = groupsArray.find(g => g.id === groupId);
      
      // Always zoom map to clicked group
      if (group && group.stops.length > 0 && window.stopsListMap) {
        const groupBounds = window.L.latLngBounds();
        group.stops.forEach(stop => {
          if (stop.stop_lat && stop.stop_lon) {
            const lat = parseFloat(stop.stop_lat);
            const lon = parseFloat(stop.stop_lon);
            if (!isNaN(lat) && !isNaN(lon)) {
              groupBounds.extend([lat, lon]);
            }
          }
        });
        
        if (groupBounds.isValid()) {
          window.stopsListMap.flyToBounds(groupBounds, { 
            padding: [50, 50], 
            maxZoom: 17,
            duration: 0.5
          });
        }
      }
      
      // Toggle expansion
      if (state.expandedStopGroup === groupId) {
        state.expandedStopGroup = null;
      } else {
        state.expandedStopGroup = groupId;
      }
      
      renderStopsView();
    };
    
    stopsListContainer._stopGroupHandler = groupHandler;
    stopsListContainer.addEventListener('click', groupHandler);
  }

  // Event delegation for stop items - navigate to STOP_DETAIL
  const stopsList_el = $('stops-list');
  if (stopsList_el) {
    // Remove old handler if exists
    if (stopsList_el._stopItemHandler) {
      stopsList_el.removeEventListener('click', stopsList_el._stopItemHandler);
    }
    
    // Add delegated handler
    const handler = (e) => {
      const stopItem = e.target.closest('.stop-item');
      if (!stopItem) return;
      
      const stopId = stopItem.getAttribute('data-stop-id');
      
      // Search in groupsArray for the stop
      const groupsArray = getOrBuildGroupsArray(stopsData);
      let stop = null;
      
      for (const group of groupsArray) {
        stop = group.stops.find(s => s.stop_id === stopId);
        if (stop) break;
      }
      
if (stop) {
  // USTAW MAPĘ na wybrany przystanek
  if (window.stopsListMap && stop.stop_lat && stop.stop_lon) {
    window.stopsListMap.setView(
      [parseFloat(stop.stop_lat), parseFloat(stop.stop_lon)],
      17 // lub twój ulubiony zoom
    );
  }

  // NIE mroź stanu mapy tutaj!

  state.selectedStop = stop;
  state.stopViewFilteredRoutes = [];
  render();
}
    };
    
    stopsList_el._stopItemHandler = handler;
    stopsList_el.addEventListener('click', handler);
  }
}

function collectRoutesForStop(stopId, selectedDate, filteredRouteIds = []) {
  if (!state.gtfsData || !stopId) return [];
  
  const activeServices = getServicesForDate(selectedDate);
  const routesData = [];
  
  // Zbierz wszystkie linie przechodzące przez ten przystanek
  const routesAtStop = new Map();
  
  state.gtfsData.routes.forEach(route => {
    const trips = state.gtfsData.tripsIndex[route.route_id] || [];
    let passesThrough = false;
    let tripCount = 0;
    
    trips.forEach(trip => {
      if (! activeServices.includes(trip.service_id)) return;
      const stopTimes = state.gtfsData.stopTimesIndex[trip.trip_id] || [];
      if (stopTimes.some(st => st.stop_id === stopId)) {
        passesThrough = true;
        tripCount++;
      }
    });
    
    if (passesThrough) {
      routesAtStop.set(route. route_id, { route, tripCount });
    }
  });
  
  // Jeśli jest filtr, zostaw tylko wybrane
  let routesToProcess = Array. from(routesAtStop.values());
  if (filteredRouteIds.length > 0) {
    routesToProcess = routesToProcess.filter(rd => filteredRouteIds.includes(rd.route.route_id));
  }
  
  // No limit on number of routes - removed artificial 20 route limit
  
  // UPROSZCZONA LOGIKA - jedna linia = jedna trasa (najpopularniejsza sekwencja)
  routesToProcess.forEach(({ route, tripCount }) => {
    const trips = state.gtfsData.tripsIndex[route.route_id] || [];
    const activeTrips = trips.filter(t => activeServices.includes(t.service_id));
    
    // UPROSZCZENIE: dla przystanku jest tylko jeden kierunek tej linii
    // Znajdź najpopularniejszą sekwencję przystanków
    const representative = findMostFrequentTripPattern(
      activeTrips, 
      state.gtfsData.stopTimesIndex,
      stopId,
      activeServices
    );
    
    if (!representative) return; // Brak tripów przez ten przystanek
    
    // Zbuduj listę przystanków z reprezentatywnego tripu
    const stopsToDraw = [];
    representative.stopIds.forEach(sid => {
      const stop = state.gtfsData.stopsIndex[sid];
      if (stop && stop.stop_lat && stop.stop_lon) {
        const lat = parseFloat(stop.stop_lat);
        const lon = parseFloat(stop.stop_lon);
        if (!isNaN(lat) && !isNaN(lon)) {
          stopsToDraw.push({
            id: sid,
            lat,
            lon,
            name: stop.stop_name || sid,
            type: 'core'
          });
        }
      }
    });
    
    if (stopsToDraw.length > 1) {
      const meta = getRouteTypeMeta(route.route_type);
      
      // Pobierz shape_id i direction_id z reprezentatywnego tripu
      const representativeTrip = activeTrips.find(t => t.trip_id === representative.tripId);
      const shapeId = representativeTrip?.shape_id || null;
      const direction = representativeTrip?.direction_id || '0';
      
      routesData.push({
        route,
        direction: direction,
        directionName: `Direction ${direction}`,
        stops: stopsToDraw,
        color: meta.color || '#3b82f6',
        tripCount: representative.frequency,
        shapeId: shapeId
      });
    }
  });
  
  return { routes: routesData };
}

function updateRouteFilterButtons() {
  const allBtn = $('filter-all-routes');
  if (allBtn) {
    if (state.stopViewFilteredRoutes.length === 0) {
      allBtn.className = allBtn.className.replace(/bg-white hover:bg-gray-50/g, 'bg-blue-500 text-white');
    } else {
      allBtn.className = allBtn.className.replace(/bg-blue-500 text-white/g, 'bg-white hover:bg-gray-50');
    }
  }
  
  $$('.route-filter-btn').forEach(btn => {
    const routeId = btn.getAttribute('data-route-id');
    const isSelected = state.stopViewFilteredRoutes.includes(routeId);
    if (isSelected) {
      btn.className = btn.className.replace(/bg-white hover:bg-gray-50/g, 'bg-blue-500 text-white');
    } else {
      btn.className = btn.className.replace(/bg-blue-500 text-white/g, 'bg-white hover:bg-gray-50');
    }
  });
}

function updateDeparturesTable() {
  const tableContainer = document.querySelector('#stop-detail-departures-table');
  if (!tableContainer || !state.stopDetailDepartures) return;
  
  // Filter departures based on current filter
  let filteredDepartures = state.stopDetailDepartures;
  if (state.stopViewFilteredRoutes.length > 0) {
    filteredDepartures = state.stopDetailDepartures.filter(d => 
      state.stopViewFilteredRoutes.includes(d.route.route_id)
    );
  }
  
  // Generate table HTML
  if (filteredDepartures.length === 0) {
    tableContainer.innerHTML = '<div class="text-gray-700 p-4">No departures found</div>';
  } else {
    const tableHtml = `
<table
  class="text-sm border w-full"
  style="border-collapse: collapse; table-layout: fixed;"
>
  <colgroup>
    <col style="width:4.5em">
    <col style="width:max-content">
    <col style="width:100%">
  </colgroup>

  <thead class="bg-gray-50 sticky top-0 z-10">
    <tr>
      <th class="text-left p-3 font-semibold border whitespace-nowrap">
        Czas
      </th>
      <th class="text-left p-3 font-semibold border whitespace-nowrap">
        Linia
      </th>
      <th class="text-left p-3 font-semibold border">
        Kierunek
      </th>
    </tr>
  </thead>

  <tbody>
    ${filteredDepartures.map(dep => {
      const meta = getRouteTypeMeta(dep.route.route_type);

      return '<tr class="border-b hover:bg-gray-50">' +
        '<td class="p-1 font-bold border whitespace-nowrap text-center">' +
          formatTime(dep.time) +
        '</td>' +
        '<td class="p-1 border whitespace-nowrap">' +
          '<div class="flex justify-center">' +
            routeBadgeHtml(dep.route, meta) +
          '</div>' +
        '</td>' +
        '<td class="p-1 border break-words">' +
          escapeHtml(dep.headsign || "-") +
        '</td>' +
      '</tr>';
    }).join("")}
  </tbody>
</table>
`;
    tableContainer.innerHTML = tableHtml;
  }
}

// ═══════════════════════════════════════════════════════════════
// 13. UI RENDERING - TIMETABLE
// ═══════════════════════════════════════════════════════════════
function renderTimetable() {
  const container = $('timetable-container'); 
  if (!container) return;
  container.innerHTML = `
    <div class="flex gap-4 items-center mb-4">
      <button id="toggle-depot-trips-main" class="bg-blue-500 text-white px-4 py-2 rounded hover:bg-blue-600">
        ${state.showAllTrips ? 'Ukryj zjazdy i wyjazdy' : 'Pokaż zjazdy i wyjazdy'}
      </button>
    </div>
    <div id="schedule-table-root"></div>
`;
      $('toggle-depot-trips-main').onclick = () => { 
        // FIX #4: Save scroll position before toggling
        const scrollContainer = tableRoot?.querySelector('.overflow-x-auto');
        const savedScrollLeft = scrollContainer ? scrollContainer.scrollLeft : 0;
        const savedScrollTop = scrollContainer ? scrollContainer.scrollTop : 0;
        
        state.showAllTrips = !state.showAllTrips; 
        renderTimetable(); 
        
        // Restore scroll position after render
        setTimeout(() => {
          const newScrollContainer = $('schedule-table-root')?.querySelector('.overflow-x-auto');
          if (newScrollContainer) {
            newScrollContainer.scrollLeft = savedScrollLeft;
            newScrollContainer.scrollTop = savedScrollTop;
          }
        }, 0);
      };

      const tableRoot = $('schedule-table-root'); if (!tableRoot) return;

// === STEP 1: Get ALL trips for current route/group + direction ===
const trips = getAllTripsForRoute();
if (trips.length === 0) {
  tableRoot.innerHTML = "<div class='p-4 text-gray-500'>No schedule available.</div>";
  return;
}

const variantsData = computeVariantsForRoute();
const tripToVariantGlobal = variantsData ? variantsData.tripToVariant : {};

if (variantsData && variantsData.variantDetails) {
  const available = Object.keys(variantsData.variantDetails).map(k=>parseInt(k,10)).filter(n=>!isNaN(n));
  if (available.length>0 && !available.includes(state.selectedVariant)) state.selectedVariant = available[0];
}

// === STEP 2: Try to get canonical master list (stable rows) ===
let masterList = ensureCanonicalMasterListForCurrentSelection();
let usingCanonical = !!masterList;

// Build tripStopMaps for current date's trips (all stops, including tail)
const tripStopMaps = {};
trips.forEach(trip => {
  const stopTimes = state.gtfsData.stopTimesIndex[trip.trip_id] || [];
  stopTimes.sort((a,b)=>parseInt(a.stop_sequence||'0') - parseInt(b.stop_sequence||'0'));
  tripStopMaps[trip.trip_id] = stopTimes;
});

const profile = getCurrentRouteProfile();
const nodeTypes = profile && profile.nodeTypes ? profile.nodeTypes : null;
const stopMetadata = profile && profile.stopMetadata ? profile.stopMetadata : null;

// === STEP 3: Process trips (detect tail stops, filter if needed) ===
// This determines which TRIPS to show, not which ROWS
const thresh = state.threshold/100;
const totalTrips = trips.length;
const edgeCount = {};
trips.forEach(trip => {
  const stops = tripStopMaps[trip.trip_id] || [];
  for (let i=0;i<stops.length-1;i++){
    const edge = stops[i].stop_id + '->' + stops[i+1].stop_id;
    edgeCount[edge] = (edgeCount[edge]||0) + 1;
  }
});

const processedTrips = trips.map(trip => {
  const stops = tripStopMaps[trip.trip_id] || [];
  let pStops = [];
  
  // Find first and last core indices for this trip (if profile exists)
  let firstCoreIdx = -1;
  let lastCoreIdx = -1;
  
  if (profile && profile.coreStops) {
    const coreStopsSet = new Set(profile.coreStops);
    for (let i = 0; i < stops.length; i++) {
      if (coreStopsSet.has(stops[i].stop_id)) {
        if (firstCoreIdx === -1) firstCoreIdx = i;
        lastCoreIdx = i;
      }
    }
  }
  
  for (let i = 0; i < stops.length; i++) {
    const s = stops[i];
    const sId = s.stop_id;

    // Odczytaj metadane z profilu (jeśli dostępne)
    const meta = stopMetadata ? stopMetadata[sId] : null;
    const profileNodeType = nodeTypes ? nodeTypes[sId] : null;
    
    let isStopTech = false;
    let isOnDemand = false;

    if (meta) {
      // === NEW LOGIC: Use profile nodeTypes (with recursive classification) ===
      const nodeType = nodeTypes[sId];
      
      if (nodeType === 'tail') {
        // Depot/technical stop
        isStopTech = true;
      } else if (nodeType === 'passenger' || nodeType === 'core') {
        // Passenger stop (including branches between core)
        isStopTech = false;
        // Check for on-demand BEFORE normalization (types 2,3 are on-demand)
        const pType = s.pickup_type ? String(s.pickup_type).trim() : "0";
        const dType = s.drop_off_type ? String(s.drop_off_type).trim() : "0";
        isOnDemand = (pType === "2" || pType === "3" || dType === "2" || dType === "3");
      } else {
        // Fallback for unclassified stops (noncore, branch, etc.)
        // Check GTFS flags to determine if technical
        const pType = s.pickup_type ? String(s.pickup_type).trim() : "0";
        const dType = s.drop_off_type ? String(s.drop_off_type).trim() : "0";
        const isStrictlyTechnical = (pType === "1" && dType === "1");
        
        if (isStrictlyTechnical) {
          isStopTech = true;
        } else if (i === 0 && pType === "1") {
          isStopTech = true;
        } else if (i === stops.length - 1 && dType === "1") {
          isStopTech = true;
        } else {
          // Default to passenger for backward compatibility
          isStopTech = false;
          isOnDemand = (pType === "2" || pType === "3" || dType === "2" || dType === "3");
        }
      }
      
    } else {
      // === FALLBACK: Stara logika (jeśli brak profilu lub metadanych) ===
      const pType = s.pickup_type ? String(s.pickup_type).trim() : "0";
      const dType = s.drop_off_type ? String(s.drop_off_type).trim() : "0";

      isOnDemand = (pType === "2" || pType === "3" || dType === "2" || dType === "3");
      const isStrictlyTechnical = (pType === "1" && dType === "1");

      let isLikelyDepot = isStrictlyTechnical;
      if (!isLikelyDepot) {
        if (i === 0 && pType === "1") {
          isLikelyDepot = true;
        } else if (i === stops.length - 1 && dType === "1") {
          isLikelyDepot = true;
        }
      }

      let isRareBefore = false, isRareAfter = false;
      if (i > 0) {
        const eB = stops[i - 1].stop_id + '->' + sId;
        if ((edgeCount[eB] || 0) / totalTrips < thresh) isRareBefore = true;
      }
      if (i < stops.length - 1) {
        const eA = sId + '->' + stops[i + 1].stop_id;
        if ((edgeCount[eA] || 0) / totalTrips < thresh) isRareAfter = true;
      }

      isStopTech = isLikelyDepot;
      if (!isStopTech) {
        if (i === 0) isStopTech = isRareAfter;
        else if (i === stops.length - 1) isStopTech = isRareBefore;
        else isStopTech = (isRareBefore && isRareAfter);
      }

      const isProfiledAsTail = (profileNodeType === 'tail');
      if (isProfiledAsTail) {
        isStopTech = true;
      } else if (isOnDemand) {
        isStopTech = false;
      }
    }

    if (!isStopTech || state.showAllTrips) {
      pStops.push({ ...s, isTech: isStopTech, isOnDemand: isOnDemand });
    }
  }
  
  // Determine if trip has passenger stops INSIDE core (between first and last core)
  let hasPassengerInsideCore = false;
  if (firstCoreIdx !== -1 && lastCoreIdx !== -1 && firstCoreIdx < lastCoreIdx) {
    // Check for passenger stops between first and last core
    for (let i = firstCoreIdx + 1; i < lastCoreIdx; i++) {
      const pStop = pStops.find(ps => ps.stop_id === stops[i].stop_id);
      if (pStop && !pStop.isTech) {
        hasPassengerInsideCore = true;
        break;
      }
    }
  }
  
  const hasPassenger = pStops.some(s => !s.isTech);
  return { ...trip, pStops, hasPassenger, hasPassengerInsideCore, firstCoreIdx, lastCoreIdx };
}).filter(t => t.pStops.length > 0 && (state.showAllTrips || t.hasPassenger));

if (processedTrips.length === 0) { 
  tableRoot.innerHTML = "<div class='p-4 text-gray-500'>No trips for this threshold.</div>"; 
  return; 
}

// === STEP 4: Build/sort trips and create mappings ===
let sortedTrips = sortTripsByMostFrequentStop(processedTrips, tripStopMaps, state.gtfsData.stopsIndex);
sortedTrips = sortedTrips.map(t => {
  const firstStop = t.pStops[0];
  let start = firstStop?.departure_time || "00:00:00";
  if (String(start).match(/^\d:/)) start = "0" + start;
  return { ...t, start };
});

const newTripStopMaps = {};
sortedTrips.forEach(t => {
  newTripStopMaps[t.trip_id] = t.pStops;
});

// === STEP 5: Get master list (canonical or fallback) ===
if (!usingCanonical) {
  // Fallback: use old buildMasterList
  masterList = buildMasterList(sortedTrips, newTripStopMaps, state.gtfsData.stopsIndex);
}

if (!masterList || masterList.length === 0) {
  tableRoot.innerHTML = "<div class='p-4 text-gray-500'>Unable to build schedule.</div>";
  return;
}

// Create trip mappings against canonical/fallback master list
const tripMappings = createTripMappings(sortedTrips, newTripStopMaps, masterList);

// === STEP 6: Compute visible row indices (FILTER rows, never reorder) ===
const visibleRowIndices = [];
const visiblePassengerRowIndices = []; // Only passenger rows (excluding tail)

masterList.forEach((mStop, mIdx) => {
  // Rule 1: Hide tail rows when showAllTrips is OFF
  if (!state.showAllTrips && mStop.nodeType === 'tail') {
    return; // Skip this row
  }
  
  // Rule 2: Hide rows with no departures for current date in any trip
  // (Check if at least one trip in sortedTrips has a stop time at this row)
  let hasAnyDeparture = false;
  for (let tripIdx = 0; tripIdx < sortedTrips.length; tripIdx++) {
    const mapping = tripMappings[tripIdx];
    if (mapping[mIdx]) {
      hasAnyDeparture = true;
      break;
    }
  }
  
  if (!hasAnyDeparture) {
    return; // Skip this row - no trips stop here on this date
  }
  
  // Row is visible
  visibleRowIndices.push(mIdx);
  
  // Track passenger rows separately for adjacent-swaps ordering
  if (mStop.nodeType !== 'tail') {
    visiblePassengerRowIndices.push(mIdx);
  }
});

// === STEP 7: Apply adjacent-swaps column ordering (reorder TRIPS, not rows) ===
// Separate trips into service (with passenger inside core) and depot (without)
const serviceTrips = [];
const depotTrips = [];

sortedTrips.forEach(trip => {
  if (trip.hasPassengerInsideCore) {
    serviceTrips.push(trip);
  } else {
    depotTrips.push(trip);
  }
});

// Build cache key for column order
const key = getCanonicalKeyForCurrentSelection() || 'fallback';
const dir = state.selectedDirection || '0';
const columnOrderCacheKey = `${key}::${dir}::${state.selectedDate}::${state.showAllTrips}`;

// Order service trips using adjacent-swaps algorithm on passenger rows only
let orderedServiceTrips = serviceTrips;
if (usingCanonical && serviceTrips.length > 0) {
  const serviceTripMappings = serviceTrips.map(trip => {
    const originalIdx = sortedTrips.findIndex(t => t.trip_id === trip.trip_id);
    return tripMappings[originalIdx];
  });
  
  // Check cache
  if (state.columnOrderCache[columnOrderCacheKey]) {
    const cachedTripIds = state.columnOrderCache[columnOrderCacheKey];
    const tripMap = new Map(serviceTrips.map(t => [t.trip_id, t]));
    orderedServiceTrips = cachedTripIds
      .map(tid => tripMap.get(tid))
      .filter(Boolean);
    
    // If cache doesn't match, recompute
    if (orderedServiceTrips.length !== serviceTrips.length) {
      orderedServiceTrips = adjacentSwapOrder(
        serviceTrips,
        serviceTripMappings,
        visiblePassengerRowIndices, // Use only passenger rows for ranking
        adjacentSwapOrderConfig
      );
      state.columnOrderCache[columnOrderCacheKey] = orderedServiceTrips.map(t => t.trip_id);
    }
  } else {
    // Compute and cache
    orderedServiceTrips = adjacentSwapOrder(
      serviceTrips,
      serviceTripMappings,
      visiblePassengerRowIndices, // Use only passenger rows for ranking
      adjacentSwapOrderConfig
    );
    state.columnOrderCache[columnOrderCacheKey] = orderedServiceTrips.map(t => t.trip_id);
  }
}

// Order depot trips by firstCoreTime
const orderedDepotTrips = depotTrips.slice().sort((a, b) => {
  // Get firstCoreTime for each trip
  const getFirstCoreTime = (trip) => {
    if (!profile || !profile.coreStops) return null;
    const coreStopsSet = new Set(profile.coreStops);
    const stops = newTripStopMaps[trip.trip_id] || [];
    
    for (let i = 0; i < stops.length; i++) {
      if (coreStopsSet.has(stops[i].stop_id)) {
        return stops[i].departure_time || stops[i].arrival_time;
      }
    }
    return null;
  };
  
  const timeA = getFirstCoreTime(a);
  const timeB = getFirstCoreTime(b);
  
  // Both have firstCoreTime - compare
  if (timeA && timeB) {
    const diff = timeToMinutes(timeA) - timeToMinutes(timeB);
    if (diff !== 0) return diff;
  } else if (timeA) {
    return -1; // a has time, b doesn't - a comes first
  } else if (timeB) {
    return 1; // b has time, a doesn't - b comes first
  }
  
  // Tie-breaker: trip_id
  return a.trip_id.localeCompare(b.trip_id);
});

// Combine: service trips first (adjacent-swaps ordered), then depot trips (by firstCoreTime)
let orderedTrips;
if (state.showAllTrips) {
  orderedTrips = [...orderedServiceTrips, ...orderedDepotTrips];
} else {
  // When showAllTrips is false, only show service trips
  orderedTrips = orderedServiceTrips;
}

// Rebuild trip mappings in the new order
const orderedTripMappings = orderedTrips.map(trip => {
  const originalIdx = sortedTrips.findIndex(t => t.trip_id === trip.trip_id);
  return tripMappings[originalIdx];
});

// Use orderedTrips and orderedTripMappings for rendering
sortedTrips = orderedTrips;
const finalTripMappings = orderedTripMappings;

// === POPULATE CACHED TIMETABLE DATA FOR MODAL ===
// Store all trips (including those that might be hidden)
state.currentTimetableData.allTrips = trips; // Store ALL trips before filtering

// Build stopDepartures map for each stop in masterList
const stopDepartures = {};
masterList.forEach((mStop) => {
  const allStopIds = mStop.stopIds || [mStop.id];
  
  // Collect all departures for this stop (including hidden trips)
  const departures = [];
  
  // Go through ALL trips (not just sortedTrips) to include hidden ones
  trips.forEach(trip => {
    const stopTimes = state.gtfsData.stopTimesIndex[trip.trip_id] || [];
    const stopTime = stopTimes.find(st => allStopIds.includes(st.stop_id));
    
    if (stopTime) {
      const departureTime = stopTime.departure_time || stopTime.arrival_time;
      if (departureTime) {
        departures.push({
          trip_id: trip.trip_id,
          time: departureTime,
          trip: trip,
          service_id: trip.service_id,
          headsign: trip.trip_headsign || ''
        });
      }
    }
  });
  
  // Store departures for all stopIds in this merged stop
  allStopIds.forEach(stopId => {
    stopDepartures[stopId] = departures;
  });
});

state.currentTimetableData.stopDepartures = stopDepartures;
// === END CACHED DATA ===
      
      // Tabela z pełnym obramowaniem
      let html = '<div class="overflow-x-auto"><table class="text-sm border-collapse border border-gray-300 w-full bg-white"><thead class="bg-gray-50 sticky top-0">';
      html += '<tr>';
      
// NAGŁÓWEK "Stop Name": 
      // padding: 14px (góra/dół - wysokość) 8px (prawo) 14px (dół) 24px (lewo - wcięcie)
      html += '<th class="text-left font-semibold border border-gray-300 sticky left-0 bg-gray-50 z-30" style="min-width: 250px; padding: 14px 8px 14px 10px;">Przystanek</th>';
      
      sortedTrips.forEach(trip => {
        const vNum = tripToVariantGlobal[trip.trip_id] || 1;
        const isSelected = state.selectedVariant === vNum;
        html += `<th class="p-1 font-semibold border border-gray-300 text-center whitespace-nowrap text-xs cursor-pointer ${isSelected ? 'bg-blue-500 text-white' : 'bg-gray-200 hover:bg-gray-300'}" style="width:58px;" data-variant="${vNum}" tabindex="0" role="button">#${vNum}</th>`;
      });
      html += '</tr></thead><tbody>';

      // Main loop: generate each row for VISIBLE stops only
      visibleRowIndices.forEach((mIdx) => {
        const mStop = masterList[mIdx];
        html += '<tr class="hover:bg-gray-50">';
        
        const isOnDemandStop = sortedTrips.some(trip => {
          const stopMatch = newTripStopMaps[trip.trip_id]?.find(st => st.stop_id === mStop.id);
          return stopMatch?.isOnDemand;
        });
        
        // First column: stop name cell with onclick for modal
        // Note: mStop.id and mStop.name are escaped to prevent XSS
        html += `<td class="p-2 font-medium sticky left-0 bg-white border border-gray-300 cursor-pointer hover:bg-blue-50 z-10" style="min-width:250px; padding-left: 10px;" onclick="openStopTimetable('${escapeHtml(mStop.id)}')">${escapeHtml(mStop.name)}${isOnDemandStop ? ' <span style="color: #ff0000; font-style: normal; margin-left: 4px;">&#128276;</span>' : ''}</td>`;

        // FIX #8: Check if this is a merged stop for tooltips on time cells
        const isMergedStop = mStop.stopIds && mStop.stopIds.length > 1;

        // Inner loop: generate time cells for each trip
        finalTripMappings.forEach((mapping, tripIdx) => {
          const stopMatch = mapping[mIdx];
          const trip = sortedTrips[tripIdx];
          
          if (stopMatch) {
            // Zbuduj tooltip dla TEGO KONKRETNEGO stop_id (nie pierwszego!)
            let cellTooltip = '';
            
            if (isMergedStop) {
              const actualStopId = stopMatch.stop_id;  // ← Właściwy stop_id dla TEJ komórki!
              const stopData = state.gtfsData.stopsIndex[actualStopId];
              
              if (stopData) {
                const infoParts = [];
                if (stopData.stop_id) infoParts.push(`ID: ${escapeHtml(stopData.stop_id)}`);
                if (stopData.stop_desc) infoParts.push(escapeHtml(stopData.stop_desc));
                if (stopData.platform_code) infoParts.push(`Peron: ${escapeHtml(stopData.platform_code)}`);
                
                if (infoParts.length > 0) {
                  cellTooltip = infoParts.join('<br>');
                }
              }
            }
            
            // Renderuj komórkę z właściwym tooltipem
            if (cellTooltip) {
              html += `<td class="p-1 text-center text-xs border border-gray-300 time-cell-with-tooltip">
                ${formatTime(stopMatch.departure_time || stopMatch.arrival_time)}
                <span class="tooltip-content">${cellTooltip}</span>
              </td>`;
            } else {
              // No tooltip for non-merged stops
              html += `<td class="p-1 text-center text-xs border border-gray-300">
                ${formatTime(stopMatch.departure_time || stopMatch.arrival_time)}
              </td>`;
            }
          } else {
            // FIX #7: Add "&lt;" symbol for empty cells to indicate no service
            html += '<td class="p-1 text-center text-xs border border-gray-300 text-gray-400">&lt;</td>';
          }
        });
        
        html += '</tr>';
      });
      html += '</tbody></table></div>';
      tableRoot.innerHTML = html;
      
      // FIX #5: Add tooltip positioning on hover
      setTimeout(() => {
        const timeCells = tableRoot.querySelectorAll('.time-cell-with-tooltip');
        timeCells.forEach(cell => {
          cell.addEventListener('mouseenter', function(e) {
            const tooltip = this.querySelector('.tooltip-content');
            if (!tooltip) return;
            
            const cellRect = this.getBoundingClientRect();
            const tooltipRect = tooltip.getBoundingClientRect();
            
            // Position tooltip above the cell, centered
            const top = cellRect.top - tooltipRect.height - 8;
            const left = cellRect.left + (cellRect.width / 2) - (tooltipRect.width / 2);
            
            // Adjust if tooltip would go off-screen
            const finalTop = Math.max(10, top);
            const finalLeft = Math.max(10, Math.min(left, window.innerWidth - tooltipRect.width - 10));
            
            tooltip.style.top = finalTop + 'px';
            tooltip.style.left = finalLeft + 'px';
          });
        });
      }, 0);
      
      const thead = tableRoot.querySelector('thead');
      if (thead && !thead.dataset.variantListenerAttached) {
        function applyHeaderSelection(rootThead) {
          if (!rootThead) return;
          $$('th[data-variant]', rootThead).forEach(h => {
            const hv = parseInt(h.getAttribute('data-variant'), 10) || 1;
            if (hv === state.selectedVariant) {
              h.classList.remove('bg-gray-200', 'hover:bg-gray-300');
              h.classList.add('bg-blue-500', 'text-white');
              h.setAttribute('aria-pressed', 'true');
            } else {
              h.classList.remove('bg-blue-500', 'text-white');
              h.classList.add('bg-gray-200');
              h.setAttribute('aria-pressed', 'false');
            }
          });
        }
        thead.addEventListener('click', async (evt) => {
          const th = evt.target.closest('th[data-variant]');
          if (!th) return;
          const v = parseInt(th.getAttribute('data-variant'), 10) || 1;
          if (state.selectedVariant === v) return;
          state.selectedVariant = v;
          applyHeaderSelection(thead);
          if (typeof updateMap === 'function') await updateMap();
        });
        thead.addEventListener('keydown', async (evt) => {
          if (evt.key !== 'Enter' && evt.key !== ' ') return;
          const th = evt.target.closest('th[data-variant]');
          if (!th) return;
          evt.preventDefault();
          const v = parseInt(th.getAttribute('data-variant'), 10) || 1;
          if (state.selectedVariant === v) return;
          state.selectedVariant = v;
          applyHeaderSelection(thead);
          if (typeof updateMap === 'function') await updateMap();
          th.focus();
        });
        const scheduleRoot = $('schedule-table-root');
        if (scheduleRoot && !scheduleRoot.dataset.variantObserverAttached) {
          const mo = new MutationObserver((mutations) => {
            const newThead = scheduleRoot.querySelector('thead');
            if (newThead) applyHeaderSelection(newThead);
          });
          mo.observe(scheduleRoot, { childList: true, subtree: true });
          scheduleRoot.dataset.variantObserverAttached = '1';
        }
        applyHeaderSelection(thead);
        thead.dataset.variantListenerAttached = '1';
      }
    }

function openStopTimetable(stopId) {
  if (!state.selectedRoute || !state.gtfsData || !state.selectedDate) return;
  const stop = state.gtfsData.stopsIndex[stopId];
  if (!stop) return;

  // Use cached data if available, otherwise fallback to old logic
  const useCachedData = state.currentTimetableData && 
                        state.currentTimetableData.stopDepartures && 
                        state.currentTimetableData.stopDepartures[stopId];

  let allDepartures = [];
  
  if (useCachedData) {
    // NEW: Use cached departure data from renderTimetable
    allDepartures = state.currentTimetableData.stopDepartures[stopId] || [];
  } else {
    // FALLBACK: Old logic for backward compatibility
    const routeTrips = state.gtfsData.tripsIndex[state.selectedRoute.route_id] || [];
    const directionTrips = routeTrips.filter(t => (t.direction_id || '0') === state.selectedDirection);
    
    directionTrips.forEach(trip => {
      const stopTimes = state.gtfsData.stopTimesIndex[trip.trip_id] || [];
      const stopTime = stopTimes.find(st => st.stop_id === stopId);
      
      if (stopTime) {
        const departureTime = stopTime.departure_time || stopTime.arrival_time;
        if (departureTime) {
          allDepartures.push({
            trip_id: trip.trip_id,
            time: departureTime,
            trip: trip,
            service_id: trip.service_id,
            headsign: trip.trip_headsign || ''
          });
        }
      }
    });
  }

  // Determine main destination - use getAvailableDirections() for consistency
  let mainDestination = '';
  let mainTerminusStopId = null;
  const routeTrips = state.gtfsData.tripsIndex[state.selectedRoute.route_id] || [];
  const directionTrips = routeTrips.filter(t => (t.direction_id || '0') === state.selectedDirection);
  
  // Try to get direction name from getAvailableDirections() first
  try {
    const directions = getAvailableDirections();
    const currentDir = directions.find(d => String(d.id) === String(state.selectedDirection));
    if (currentDir) {
      mainDestination = currentDir.fullName || currentDir.name || '';
    }
  } catch (e) {
    // Ignore getAvailableDirections errors - fallback logic handles missing direction data
  }
  
  // Fallback: use old headsign counting logic if needed
  if (!mainDestination) {
    const headsigns = directionTrips.map(t => t.trip_headsign).filter(h => h);
    const headsignCounts = {};
    headsigns.forEach(h => { headsignCounts[h] = (headsignCounts[h] || 0) + 1; });
    let maxCount = 0;
    Object.keys(headsignCounts).forEach(h => {
      if (headsignCounts[h] > maxCount) {
        maxCount = headsignCounts[h];
        mainDestination = h;
      }
    });
  }

  // Find terminus stop for legend
  if (mainDestination && directionTrips.length > 0) {
    const trip = directionTrips.find(t => t.trip_headsign === mainDestination);
    if (trip) {
      const stopTimes = state.gtfsData.stopTimesIndex[trip.trip_id] || [];
      if (stopTimes.length > 0) {
        const sortedStopTimes = [...stopTimes].sort((a, b) => parseInt(a.stop_sequence) - parseInt(b.stop_sequence));
        const lastStopTime = sortedStopTimes[sortedStopTimes.length - 1];
        mainTerminusStopId = lastStopTime.stop_id;
      }
    }
  }

  if (!mainDestination && directionTrips.length > 0) {
    const firstTrip = directionTrips[0];
    const stopTimes = state.gtfsData.stopTimesIndex[firstTrip.trip_id] || [];
    if (stopTimes.length > 0) {
      const lastStopTime = stopTimes[stopTimes.length - 1];
      const lastStop = state.gtfsData.stopsIndex[lastStopTime.stop_id];
      mainDestination = lastStop?.stop_name || '';
      mainTerminusStopId = lastStopTime.stop_id;
    }
  }

  // Get service dates
  const weekdayDate = getWeekdayDate();
  const saturdayDate = findDateForDayOfWeek(SATURDAY);
  const sundayDate = findDateForDayOfWeek(SUNDAY);
  const weekdayServices = weekdayDate ? getServicesForDate(weekdayDate) : [];
  const saturdayServices = saturdayDate ? getServicesForDate(saturdayDate) : [];
  const sundayServices = sundayDate ? getServicesForDate(sundayDate) : [];

  // Filter departures by day of week
  const weekdayDepartures = allDepartures.filter(d => weekdayServices.includes(d.service_id));
  const saturdayDepartures = allDepartures.filter(d => saturdayServices.includes(d.service_id));
  const sundayDepartures = allDepartures.filter(d => sundayServices.includes(d.service_id));

  const alternativeTermini = new Map();
  let nextLetter = 'a';

  const getTripTerminus = (tripId) => {
    const stopTimes = state.gtfsData.stopTimesIndex[tripId] || [];
    if (stopTimes.length === 0) return null;
    const sortedStopTimes = [...stopTimes].sort((a, b) => parseInt(a.stop_sequence) - parseInt(b.stop_sequence));
    const lastStopTime = sortedStopTimes[sortedStopTimes.length - 1];
    return lastStopTime.stop_id;
  };

  const getTimesByHour = (departures) => {
    const hourGroups = {};
    departures.forEach(departure => {
      if (!departure.time) return;
      const [hourStr, minute] = departure.time.split(':');
      let hour = parseInt(hourStr, 10);
      let displayHour = hour % 24;
      
      if ((hour >= 4 && hour < 24) || (hour >= 24 && hour < 28)) {
        const terminusStopId = getTripTerminus(departure.trip_id);
        let annotation = '';
        
        if (terminusStopId && terminusStopId !== mainTerminusStopId) {
          const tripHeadsign = departure.headsign;
          if (tripHeadsign && tripHeadsign !== mainDestination) {
            if (!alternativeTermini.has(tripHeadsign)) {
              alternativeTermini.set(tripHeadsign, nextLetter);
              nextLetter = String.fromCharCode(nextLetter.charCodeAt(0) + 1);
            }
            annotation = alternativeTermini.get(tripHeadsign);
          } else if (!tripHeadsign) {
            const terminusStop = state.gtfsData.stopsIndex[terminusStopId];
            const terminusName = terminusStop?.stop_name || terminusStopId;
            if (terminusName !== mainDestination) {
              if (!alternativeTermini.has(terminusName)) {
                alternativeTermini.set(terminusName, nextLetter);
                nextLetter = String.fromCharCode(nextLetter.charCodeAt(0) + 1);
              }
              annotation = alternativeTermini.get(terminusName);
            }
          }
        }
        
        if (/^[0-5]\d$/.test(minute)) {
          if (!hourGroups[displayHour]) hourGroups[displayHour] = [];
          hourGroups[displayHour].push(minute + annotation);
        }
      }
    });

    Object.keys(hourGroups).forEach(hour => {
      hourGroups[hour].sort((a, b) => parseInt(a) - parseInt(b));
    });

    const hourOrder = [];
    for (let h = 4; h < 24; h++) hourOrder.push(h);
    for (let h = 0; h < 4; h++) hourOrder.push(h);
    const filteredOrder = hourOrder.filter(h => hourGroups[h]);
    const result = {};
    filteredOrder.forEach(h => { result[h] = hourGroups[h]; });
    return result;
  };

  const weekdayTimes = getTimesByHour(weekdayDepartures);
  const saturdayTimes = getTimesByHour(saturdayDepartures);
  const sundayTimes = getTimesByHour(sundayDepartures);

  const formatTimesByHour = (timesByHour) => {
    if (Object.keys(timesByHour).length === 0) return '<span style="color: #999;">No service</span>';
    const rows = [];
    const hourOrder = [];
    for (let h = 4; h < 24; h++) hourOrder.push(h);
    for (let h = 0; h < 4; h++) hourOrder.push(h);
    const hours = hourOrder.filter(h => timesByHour.hasOwnProperty(h));
    hours.forEach((hour, index) => {
      const hourPadded = String(hour).padStart(2,'0');
      const minutes = timesByHour[hour].join('  ');
      const bgColor = index % 2 === 0 ? '#e4e7eb' : '#ffffff';
      rows.push(`<div style="margin-bottom: 0; background: ${bgColor}; padding: 0.1rem 0.25rem; line-height: 1.3;"><div style="background: #4a5568; color: white; padding: 0.1rem 0.3rem; display: inline-block; font-weight: bold; min-width: 1.75rem; text-align: center; font-size: 0.8rem;">${hourPadded}</div><div style="padding: 0.1rem 0.3rem; display: inline; font-size: 0.8rem;">${minutes}</div></div>`);
    });
    return rows.join('');
  };

  let legendHTML = '';
  if (alternativeTermini.size > 0) {
    const legendItems = [];
    alternativeTermini.forEach((letter, terminus) => {
      legendItems.push(`<span style="font-weight: bold;">${letter}</span> - do ${escapeHtml(terminus)}`);
    });
    legendHTML = `<div style="padding: 0.2rem 1rem; border-top: 1px solid #ddd; background: #f9fafb; font-size: 0.7rem; line-height: 1.2; margin: 0;">${legendItems.join(' • ')}</div>`;
  }

  const modalHTML = `<div id="stop-timetable-modal" style="position: fixed; top: 0; left: 0; right: 0; bottom: 0; background: rgba(0,0,0,0.5); z-index: 10000; display: flex; align-items: center; justify-content: center;"><div style="background: white; padding: 0; border-radius: 8px; max-width: 1100px; max-height: 95vh; overflow-y: auto;"><div style="display: flex; gap: 1rem; align-items: flex-start; padding: 0.75rem 1rem; border-bottom: 2px solid #ddd;"><div style="border: 3px solid #000; height: 53px; font-weight: bold; font-size: 1.9rem; text-align: center; line-height: 1.2; min-width: 93px; display: flex; align-items: center; justify-content: center;">${state.selectedRoute.route_short_name || state.selectedRoute.route_id}</div><div style="flex: 1; min-width: 0;"><div style="font-size: 1.75rem; font-weight: 900; line-height: 1.1; text-transform: uppercase;">${escapeHtml(stop.stop_name)}</div><div style="font-size: 1.5rem; font-weight: 700; line-height: 1.2; text-transform: uppercase; display: flex; align-items: center; white-space: nowrap;"><span style="margin-right: 0.3em;">&#8594;</span><span style="overflow-wrap: anywhere;">${escapeHtml(mainDestination || 'DESTINATION')}</span></div></div></div><table style="width: 100%; border-collapse: collapse; border: 1px solid #ddd;"><thead><tr style="background: #e5e7eb;"><th style="padding: 0.1rem 0.3rem; border: 1px solid #ddd; text-align: center; font-size: 0.8rem; font-weight: 700;">Weekdays</th><th style="padding: 0.1rem 0.3rem; border: 1px solid #ddd; text-align: center; font-size: 0.8rem; font-weight: 700;">Saturdays</th><th style="padding: 0.1rem 0.3rem; border: 1px solid #ddd; text-align: center; font-size: 0.8rem; font-weight: 700;">Sundays</th></tr></thead><tbody><tr><td style="padding: 0.25rem; border: 1px solid #ddd; vertical-align: top;">${formatTimesByHour(weekdayTimes)}</td><td style="padding: 0.25rem; border: 1px solid #ddd; vertical-align: top;">${formatTimesByHour(saturdayTimes)}</td><td style="padding: 0.25rem; border: 1px solid #ddd; vertical-align: top;">${formatTimesByHour(sundayTimes)}</td></tr></tbody></table>${legendHTML}</div></div>`;
  
  const modalContainer = document.createElement('div');
  modalContainer.innerHTML = modalHTML;
  document.body.appendChild(modalContainer);
  
  let modalClosed = false;
  const closeModal = () => {
    if (modalClosed) return;
    modalClosed = true;
    if (modalContainer && document.body.contains(modalContainer)) document.body.removeChild(modalContainer);
    document.removeEventListener('keydown', handleEscape);
  };
  const handleEscape = (e) => { if (e.key === 'Escape') closeModal(); };
  document.addEventListener('keydown', handleEscape);
  $('stop-timetable-modal').onclick = (e) => { if (e.target.id === 'stop-timetable-modal') closeModal(); };
}

// ═══════════════════════════════════════════════════════════════
// 14. MAIN RENDER & VIEW CONTROL
// ═══════════════════════════════════════════════════════════════
    /**
     * Określa aktualny widok aplikacji na podstawie stanu
     * @returns {string} Jeden z VIEW.*
     */
    function getCurrentView() {
      // Early returns in order of precedence - simpler flow with clear hierarchy
      if (state.loading) return VIEW.LOADING;
      if (state.error) return VIEW.ERROR;
      if (!state.gtfsData) return VIEW.UPLOAD;
      
      // Stop-related views (check selectedStop before showStopsView for specificity)
      if (!state.selectedRoute && state.showStopsView && state.selectedStop) {
        return VIEW.STOP_DETAIL;
      }
      if (!state.selectedRoute && state.showStopsView) {
        return VIEW.STOPS_LIST;
      }
      
      // Route views
      if (!state.selectedRoute) return VIEW.ROUTES_LIST;
      return VIEW.ROUTE_TIMETABLE;
    }

    function renderImmediate() {
      const root = $('root');
      const currentView = getCurrentView();
      
      let html = `<div class="h-screen flex flex-col bg-gray-50">
  <div class="bg-white shadow-sm border-b px-4 py-1">
    <div class="max-w-6xl mx-auto" style="display:flex; align-items:center; justify-content:center; position:relative; min-height: 32px;">
      
      <button id="back-button" 
        class="bg-orange-500 text-white rounded cursor-pointer hover:bg-orange-600 inline-flex items-center justify-center font-medium" 
        style="position:absolute; left:0; width: 40px; height: 32px;" aria-label="Back">
        <span style="font-size: 1rem; line-height: 1; margin-top: -1px;">←</span>
      </button>

      <h1 class="text-xl font-bold text-blue-600" style="margin:0; line-height: 32px;">GTFS Fusion</h1>

      <label class="bg-orange-500 text-white rounded cursor-pointer hover:bg-orange-600 inline-flex items-center justify-center font-medium" 
        style="position:absolute; right:0; width: 40px; height: 32px;">
        ${icons.upload(16)}
        <input type="file" accept=".zip" id="file-input-header" class="hidden" />
      </label>
      
    </div>
  </div>`;

switch(currentView) {
  case VIEW.LOADING:
    html += `<div class="flex-1 flex flex-col items-center justify-center bg-gray-50">
    <div class="text-center">
      <p class="text-gray-600 font-medium mb-4">${state.loadingStep || 'Ładowanie...'}</p>
      ${state.loadingProgress ? `
        <p class="text-gray-600 font-medium">
          ${state.loadingProgressPercent}% (${state.loadingProgress.toLocaleString()} wierszy)
        </p>
      ` : `
        <p class="text-gray-600 font-medium">Przetwarzanie...</p>
      `}
      <div style="margin-top:1rem;">
        <button id="cancel-parse" class="bg-red-500 text-white px-3 py-1 rounded hover:bg-red-600">Anuluj</button>
      </div>
    </div>
  </div>`;
    break;
    
  case VIEW.ERROR:
    html += `<div class="bg-red-100 border border-red-400 text-red-700 px-4 py-3 m-4 rounded">${state.error}</div>`;
    break;
    
  case VIEW.UPLOAD:
    html += `<div class="flex-1 flex items-center justify-center">
    <label class="bg-orange-500 text-white px-6 py-3 rounded-lg cursor-pointer hover:bg-orange-600 inline-flex items-center gap-2 text-lg font-medium">
      Załaduj GTFS
      <input type="file" accept=".zip" id="file-input" class="hidden" />
    </label>
  </div>`;
    break;
    
  case VIEW.STOP_DETAIL:
    // ========== SZCZEGÓŁOWY WIDOK PRZYSTANKU ==========
    const stop = state.selectedStop;
    
    // Handle merged stops - get all stop IDs
    const allStopIds = stop.stopIds || [stop.stop_id];
    
    // Zbierz wszystkie odjazdy dla tego przystanku
    const activeServices = getServicesForDate(state.selectedDate);
    const departures = [];
    const routesAtStop = new Map();
    
    state.gtfsData.routes.forEach(route => {
      const trips = state.gtfsData.tripsIndex[route.route_id] || [];
      trips.forEach(trip => {
        if (!activeServices.includes(trip.service_id)) return;
        const stopTimes = state.gtfsData.stopTimesIndex[trip.trip_id] || [];
        const stopTime = stopTimes.find(st => st.stop_id === stop.stop_id);
        if (stopTime) {
          const departureTime = stopTime.departure_time || stopTime.arrival_time;
          if (departureTime) {
            departures.push({
              route: route,
              trip: trip,
              time: departureTime,
              timeMinutes: timeToMinutes(departureTime),
              headsign: trip.trip_headsign || ''
            });
            if (!routesAtStop.has(route.route_id)) routesAtStop.set(route.route_id, route);
          }
        }
      });
    });
    
    departures.sort((a, b) => a.timeMinutes - b.timeMinutes);
    
    // Store departures in state for dynamic filtering
    state.stopDetailDepartures = departures;
    
    let filteredDepartures = departures;
    if (state.stopViewFilteredRoutes.length > 0) {
      filteredDepartures = departures.filter(d => state.stopViewFilteredRoutes.includes(d.route.route_id));
    }
    
    const routesArray = Array.from(routesAtStop.values());
    routesArray.sort((a, b) => {
      const na = String(a.route_short_name || a.route_id || '');
      const nb = String(b.route_short_name || b.route_id || '');
      return na.localeCompare(nb, undefined, { numeric: true, sensitivity: 'base' });
    });
    
    html += `<div class="flex-1 overflow-auto p-6">
  <div class="max-w-6xl mx-auto">
    <div class="bg-white shadow-sm p-4">
      <!-- Nagłówek -->
      <div class="header-row">
        <div class="header-left">
          <h2 class="text-2xl font-bold" style="margin:0;">${escapeHtml(stop.stop_name)}</h2>
        </div>
        <div class="title-controls">
          ${state.availableDates.length ? `<select id="date-select-stop" class="border rounded px-3 py-2 text-sm">${state.availableDates.map(d => `<option value="${escapeHtml(String(d.value))}" ${String(d.value) === String(state.selectedDate) ? 'selected' : ''}>${escapeHtml(d.label)}</option>`).join('')}</select>` : ''}
        </div>
      </div>
      <!-- Filtry -->
      <div style="margin-top:12px;">
        <div style="display:grid; grid-template-columns: repeat(16, 1fr); gap:8px;">
          <button id="filter-all-routes" class="px-2 py-1 rounded border border-black text-xs font-semibold ${state.stopViewFilteredRoutes.length === 0 ? 'bg-blue-500 text-white' : 'bg-white hover:bg-gray-50'}" style="min-height:50px; display:flex; flex-direction:column; align-items:center; justify-content:center;">
            <span>Wszystkie</span>
            <span>(${departures.length})</span>
          </button>
          ${(() => {
            const buttons = [];
            const slotsPerRow = 16;
            for (let i = 0; i < routesArray.length; i++) {
              const route = routesArray[i];
              const isSelected = state.stopViewFilteredRoutes.includes(route.route_id);
              const meta = getRouteTypeMeta(route.route_type);
              const count = departures.filter(d => d.route.route_id === route.route_id).length;
              buttons.push(`<button class="route-filter-btn px-2 py-1 rounded border border-black text-xs font-semibold ${isSelected ? 'bg-blue-500 text-white' : 'bg-white hover:bg-gray-50'}" data-route-id="${escapeHtml(route.route_id)}" style="border-left: 4px solid ${meta.color}; min-height:50px; display:flex; flex-direction:column; align-items:center; justify-content:center;">
                <span>${escapeHtml(route.route_short_name || route.route_id)}</span>
                <span>(${count})</span>
              </button>`);
            }
            const totalSlots = Math.ceil((routesArray.length + 1) / slotsPerRow) * slotsPerRow;
            const emptySlots = totalSlots - (routesArray.length + 1);
            for (let i = 0; i < emptySlots; i++) {
              buttons.push(`<div class="px-2 py-1 rounded border border-gray-300 bg-gray-100" style="min-height:50px;"></div>`);
            }
            return buttons.join('');
          })()}
        </div>
      </div>
      
<!-- Mapa i tabela -->
      <div style="margin-top:12px; display:grid; grid-template-columns: repeat(16, 1fr); gap:8px;">
        <!-- Tabela zajmuje 6 kolumn -->
        <div style="grid-column: 1 / 7;">
          <div id="stop-detail-departures-table" style="height:500px; overflow-y:auto;">
            ${filteredDepartures.length === 0 ? '<div class="text-gray-700 p-4">No departures found</div>' : `
<table
  class="text-sm border w-full"
  style="border-collapse: collapse; table-layout: fixed;"
>
  <colgroup>
    <col style="width:4.5em">
    <col style="width:max-content">
    <col style="width:100%">
  </colgroup>

  <thead class="bg-gray-50 sticky top-0 z-10">
    <tr>
      <th class="text-left p-3 font-semibold border whitespace-nowrap">
        Czas
      </th>
      <th class="text-left p-3 font-semibold border whitespace-nowrap">
        Linia
      </th>
      <th class="text-left p-3 font-semibold border">
        Kierunek
      </th>
    </tr>
  </thead>

  <tbody>
    ${filteredDepartures.map(dep => {
      const meta = getRouteTypeMeta(dep.route.route_type);

      return `
        <tr class="border-b hover:bg-gray-50">
          <td class="p-1 font-bold border whitespace-nowrap text-center">
            ${formatTime(dep.time)}
          </td>

          <!-- ROUTE: NIE ROZCIĄGA SIĘ -->
<td class="p-1 border whitespace-nowrap">
  <div class="flex justify-center">
    ${routeBadgeHtml(dep.route, meta)}
  </div>
</td>

          <!-- DESTINATION: BIERZE RESZTĘ -->
          <td class="p-1 border break-words">
            ${escapeHtml(dep.headsign || "-")}
          </td>
        </tr>
      `;
    }).join("")}
  </tbody>
</table>
`}
          </div>
        </div>
        
<!-- Mapa zaczyna się od środka między 6. a 7. kolumną (6.5) i idzie do końca -->
        <div style="grid-column: 7 / 17;">
          <div class="bg-white shadow-sm" style="height:500px; margin-left:-4px; position:relative;">
            <div id="stop-detail-map" style="width:100%; height:100%; overflow:hidden;"></div>
          </div>
        </div>
</div>`;
    break;

  case VIEW.STOPS_LIST:
    // ========== WIDOK PRZYSTANKÓW ==========
    html += `<div class="flex-1 overflow-auto p-6">
    <div class="max-w-6xl mx-auto">
      <div class="routes-header">
        <div style="display:flex; align-items:center; gap:1rem;">
          <h2 class="text-2xl font-bold" style="margin:0;">Zobacz:</h2>
          <select id="view-mode-select-stops" class="border rounded px-3 py-2 text-base font-semibold">
            <option value="routes">linie</option>
            <option value="stops" selected>przystanki</option>
          </select>
        </div>
      </div>
      
      <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 1.5rem;">
        <div class="bg-white shadow-sm" style="max-height: 600px; display: flex; flex-direction: column;">
          <div style="position: sticky; top: 0; z-index: 10; background: white; padding: 1rem; padding-bottom: 0.5rem; border-bottom: 1px solid #e5e7eb;">
            <input 
              type="text" 
              id="stops-search-input-header"
              placeholder="search" 
              class="border rounded px-3 py-2 text-sm"
              style="width: 100%;"
            />
          </div>
          <div style="flex: 1; overflow-y: auto; padding: 1rem; padding-top: 0.5rem;">
            <div id="stops-list"></div>
          </div>
        </div>
        <div class="bg-white shadow-sm">
          <div id="stops-map" style="width:100%; height:600px;"></div>
        </div>
      </div>
    </div>
  </div>`;
    break;

  case VIEW.ROUTES_LIST:
    // ========== WIDOK TRAS ==========
    html += `<div id="routes-list-container" class="flex-1 overflow-auto p-6"><div class="max-w-6xl mx-auto">
    <div class="routes-header">
      <div style="display:flex; align-items:center; gap:1rem;">
        <h2 class="text-2xl font-bold" style="margin:0;">Zobacz:</h2>
        <select id="view-mode-select" class="border rounded px-3 py-2 text-base font-semibold">
          <option value="routes" selected>linie</option>
          <option value="stops">przystanki</option>
        </select>
      </div>
      <div style="position:relative;">
        <button id="routes-options-btn" class="border rounded px-3 py-2 text-sm">Opcje ▾</button>
        <div id="routes-options" class="routes-options" style="display:none;">
          <label style="display:flex;align-items:center;gap:8px;"><span style="font-size:13px;">Grupuj według</span>
<select id="route-group-select" class="border rounded px-2 py-1 text-sm" style="margin-left:8px;">
<option value="logical" ${state.routeGroupMode==='logical'?'selected':''}>Zgrupowane linie</option>
<option value="service_type" ${state.routeGroupMode==='service_type'?'selected':''}>Środka transportu</option>
<option value="agency" ${state.routeGroupMode==='agency'?'selected':''}>Przewoźnika</option>
<option value="raw_routes" ${state.routeGroupMode==='raw_routes'?'selected':''}>route_id</option>
</select>
          </label>
        </div>
      </div>
    </div>
    <div id="routes-container" class="mb-8"><div id="routes-tbody"></div></div>
  </div></div>`;
    break;

  case VIEW.ROUTE_TIMETABLE:
    // ========== WIDOK LINII z rozkładem ==========
    // directions + displays (A / B)
    const directions = getAvailableDirections();
    const dirA = Array.isArray(directions) && directions.length >= 1 ? directions[0] : null;
    const dirB = Array.isArray(directions) && directions.length >= 2 ? directions[1] : null;
    const displayA = dirA ? (dirA.fullName || dirA.name || '') : '';
    const displayB = dirB ? (dirB.fullName || dirB.name || '') : '';
    const combinedAB = (displayA && displayB) ? `${displayA} → ${displayB}` : (displayA || displayB || '');
    
    const shortName = String(state.selectedRoute.route_short_name || '').trim();
    const longName = String(state.selectedRoute.route_long_name || '').trim();
    
    let routeTitleRaw = '';
    if (longName) {
      routeTitleRaw = longName;
    } else {
      if (combinedAB) {
        routeTitleRaw = combinedAB;
      } else {
        const selDir = Array.isArray(directions) && directions.length
          ? (directions.find(d => String(d.id) === String(state.selectedDirection)) || directions[0])
          : null;
        routeTitleRaw = selDir ? (selDir.fullName || selDir.name || '') : (state.selectedRoute.route_id || '');
      }
    }
    if (shortName && routeTitleRaw) {
      routeTitleRaw = shortName + ' ' + routeTitleRaw;
    }
    if (shortName) {
      const escaped = shortName.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
      const doubleRe = new RegExp('^' + escaped + '\\s+' + escaped + '(?:\\s|$)');
      if (doubleRe.test(routeTitleRaw)) {
        routeTitleRaw = routeTitleRaw.replace(new RegExp('^' + escaped + '\\s*'), '');
      }
    }
    const routeTitle = escapeHtml(routeTitleRaw);
    let titleWithoutShort = routeTitleRaw || '';
    if (shortName) {
      const escapedShortForRe = shortName.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
      titleWithoutShort = titleWithoutShort.replace(new RegExp('^' + escapedShortForRe + '\\s*'), '');
    }
    const shortEsc = escapeHtml(shortName);
    const titleEsc = escapeHtml(titleWithoutShort || routeTitleRaw || '');
    
    html += `<div class="flex-1 overflow-auto">
  <div class="max-w-6xl mx-auto">
    <div class="bg-white border-b p-4" style="box-sizing:border-box;">
      <div class="header-row" style="display:flex;align-items:center;gap:0.5rem;">
        <div class="header-left" style="min-width:0; display:flex; align-items:center; gap:0.5rem; flex:0 1 auto;">
          <h2 class="text-2xl font-bold" title="${escapeHtml(routeTitleRaw)}" style="margin:0; display:flex; align-items:center;">
            <span class="header-with-badge">` +
              (shortName ? `<span class="route-badge">${shortEsc}</span>` : '') +
              `<span class="route-title" title="${escapeHtml(routeTitleRaw)}">${titleEsc}</span>
            </span>
          </h2>
        </div>

        <div class="title-controls" style="margin-left:auto;display:flex;align-items:center;gap:0.5rem;flex:0 0 auto;">
          ${directions.length>1 ? `<select id="direction-select" style="width:auto;min-width:200px;display:inline-block;" class="border rounded px-3 py-2 text-sm">${directions.map(dir => `<option value="${escapeHtml(String(dir.id))}" ${String(state.selectedDirection) === String(dir.id) ? 'selected' : ''}>${escapeHtml(dir.name)}</option>`).join('')}</select>` : ''}
          ${ (state.availableDates || []).length ? `<select id="date-select" style="width:auto;min-width:160px;display:inline-block;" class="border rounded px-3 py-2 text-sm">${(state.availableDates||[]).map(d => `<option value="${escapeHtml(String(d.value))}" ${String(d.value) === String(state.selectedDate) ? 'selected' : ''}>${escapeHtml(d.label)}</option>`).join('')}</select>` : '' }
        </div>
      </div>

      <div style="margin-top:12px;">
        <div id="map-container" style="width:100%; height:420px; box-sizing:border-box; border-radius:6px; overflow:hidden; background:#fff;"></div>
        <div id="timetable-container" class="mt-4 mb-0"></div>
      </div>
    </div>
  </div>
</div>`;
    break;
}
      
      html += `</div>`;
      root.innerHTML = html;

      $('file-input')?.addEventListener('change', handleFileUpload);

      $('file-input-header')?.addEventListener('change', handleFileUpload);

      $('cancel-parse')?.addEventListener('click', cancelParsing);
      const routesOptionsBtn = $('routes-options-btn');
      const routesOptions = $('routes-options');
      if (routesOptionsBtn && routesOptions) {
        routesOptionsBtn.addEventListener('click', (e) => {
          state.routesOptionsOpen = !state.routesOptionsOpen;
          routesOptions.style.display = state.routesOptionsOpen ? 'block' : 'none';
        });
        if (!state.routesOptionsListenerAttached) {
          document.addEventListener('click', (ev) => {
            try {
              if (!$('routes-options')) return;
              const ro = $('routes-options');
              const btn = $('routes-options-btn');
              if (!ro || !btn) return;
              if (!ro.contains(ev.target) && ev.target !== btn) {
                state.routesOptionsOpen = false;
                ro.style.display = 'none';
              }
            } catch(e){}
          });
          state.routesOptionsListenerAttached = true;
        }
      }
      $('route-group-select')?.addEventListener('change', (e) => { state.routeGroupMode = e.target.value || 'route_id'; renderRouteTable(); });
      $('view-mode-select')?.addEventListener('change', (e) => {
    state.showStopsView = (e.target.value === 'stops');
    render();
  });

$('view-mode-select-stops')?.addEventListener('change', (e) => {
    state.showStopsView = (e.target.value === 'stops');
    render();
  });
$('back-button')?.addEventListener('click', () => {
    if (state.selectedStop) {
      // Powrót ze STOP_DETAIL do STOPS_LIST
      // Restore expanded group if we had one
      if (state.stopsListMapState && state.stopsListMapState.expandedGroup) {
        state.expandedStopGroup = state.stopsListMapState.expandedGroup;
      }
      // FIX #3: Reset map state when leaving STOP_DETAIL
      state.stopDetailMapInitialized = false;
      state.stopDetailMapLayers = {};
      if (state.stopDetailMapInstance) {
        try {
          state.stopDetailMapInstance.remove();
        } catch(e) {}
        state.stopDetailMapInstance = null;
      }
      state.selectedStop = null;
      state.stopViewFilteredRoutes = [];
    } else if (state.selectedRoute) {
      // Powrót z ROUTE_TIMETABLE do ROUTES_LIST
      state.selectedRoute = null;
      resetMap();
    } else if (state.showStopsView) {
      // Powrót ze STOPS_LIST do ROUTES_LIST
      state.showStopsView = false;
      state.expandedStopGroup = null;
      state.stopsListMapState = null;
      state.stopsListSearchQuery = '';
      state.routesListScrollPosition = 0; // Reset scroll position
      resetMap();
    } else if (!state.showStopsView) {
      // Powrót z ROUTES_LIST do STOPS_LIST
      state.showStopsView = true;
      state.routesListScrollPosition = 0; // Reset scroll position
      resetMap();
    }
    render(); 
  });

// -- Obsługa kliknięć na przyciskach filtrów --
const filterAllBtn = document.getElementById('filter-all-routes');
if (filterAllBtn) {
  const oldHandler = filterAllBtn._filterHandler;
  if (oldHandler) filterAllBtn.removeEventListener('click', oldHandler);
  const newHandler = () => {
    state.stopViewFilteredRoutes = [];
    filterStopDetailMapLayers(state.stopViewFilteredRoutes);
    updateRouteFilterButtons();
    updateDeparturesTable();
  };
  filterAllBtn._filterHandler = newHandler;
  filterAllBtn.addEventListener('click', newHandler);
}
document.querySelectorAll('.route-filter-btn').forEach(btn => {
  const oldHandler = btn._filterHandler;
  if (oldHandler) btn.removeEventListener('click', oldHandler);
  const newHandler = () => {
    const routeId = btn.getAttribute('data-route-id');
    const idx = state.stopViewFilteredRoutes.indexOf(routeId);
    if (idx > -1) {
      state.stopViewFilteredRoutes.splice(idx, 1);
    } else {
      state.stopViewFilteredRoutes.push(routeId);
    }
    filterStopDetailMapLayers(state.stopViewFilteredRoutes);
    updateRouteFilterButtons();
    updateDeparturesTable();
  };
  btn._filterHandler = newHandler;
  btn.addEventListener('click', newHandler);
});
// -- KONIEC BLOKU obsługi kliknięć --		

// WARNING: Do not duplicate these event listeners - they should only be registered once
// to avoid multiple callbacks firing on each change
$('direction-select')?.addEventListener('change', async (e) => {
    const newDirection = String(e.target.value);
    if (newDirection === state.selectedDirection) return; // Avoid redundant updates
    state.selectedDirection = newDirection;
    // Invalidate canonical cache when direction changes
    invalidateCanonicalCacheForCurrentSelection();
    resetMap();
    render();
  });

$('date-select')?.addEventListener('change', async (e) => {
    state.selectedDate = String(e.target.value);
    resetMap();
    render();
  });

if (state.gtfsData && !state.selectedRoute && !state.showStopsView) {
  renderRouteTable();
  // Restore scroll position after rendering routes list
  if (state.routesListScrollPosition !== undefined && state.routesListScrollPosition > 0) {
    setTimeout(() => {
      const container = document.querySelector('#routes-list-container');
      if (container) {
        container.scrollTop = state.routesListScrollPosition;
      }
    }, 50);
  }
}
if (state.gtfsData && !state.selectedRoute && state.showStopsView && state.selectedStop) {
  // Renderuj mapę z trasami linii - only once on first load
  setTimeout(async () => {
    await renderStopDetailMap(state.selectedStop.stop_id, state.selectedDate, state.stopViewFilteredRoutes);
    // FIX #3: Apply initial filter after map is initialized
    filterStopDetailMapLayers(state.stopViewFilteredRoutes);
  }, 50);
  
// replace the stop-detail date-select handler with this (if present in your file)
$('date-select-stop')?.addEventListener('change', async (e) => {
  state.selectedDate = String(e.target.value);
  state.stopDetailDepartures = [];
  
  // FIX #4: Update layers without restarting map
  if (state.stopDetailMapInstance && state.stopDetailMapInitialized) {
    const map = state.stopDetailMapInstance;
    const stopId = state.selectedStop.stop_id;
    
    // Remove old layers
    Object.values(state.stopDetailMapLayers).forEach(layer => {
      map.removeLayer(layer);
    });
    state.stopDetailMapLayers = {};
    
    // Recollect routes for new date
    const result = collectRoutesForStop(stopId, state.selectedDate, []);
    
    // No limit - removed tooMany check
    const routesData = result.routes || [];
    
    // Recreate layers
    for (const routeData of routesData) {
      const { route, stops, color, direction, shapeId } = routeData;
      const layerKey = `${route.route_id}_${direction}`;
      
      const layer = window.L.featureGroup();
      
      const mainRouteStops = stops.filter(s => s.type === 'core' || s.type === 'branch');
      
      if (mainRouteStops.length > 1) {
        let lineGeometry = null;
        
        if (shapeId && state.gtfsData.shapesIndex && state.gtfsData.shapesIndex[shapeId]) {
          lineGeometry = state.gtfsData.shapesIndex[shapeId];
        }
        
        if (!lineGeometry) {
          try {
            lineGeometry = await generateLineGeometry(mainRouteStops, route.route_type);
          } catch (err) {
            // Ignore geometry generation errors - fallback to straight lines between stops
          }
        }
        
        if (!lineGeometry || lineGeometry.length < 2) {
          lineGeometry = mainRouteStops.map(s => [s.lat, s.lon]).filter(([lat, lon]) => !isNaN(lat) && !isNaN(lon));
        }
        
        if (Array.isArray(lineGeometry) && lineGeometry.length > 1) {
          window.L.polyline(lineGeometry, {
            color: color,
            weight: 3,
            opacity: 0.7,
            smoothFactor: 0.5
          }).addTo(layer);
        }
      }
      
      mainRouteStops.forEach(s => {
        if (!s || isNaN(parseFloat(s.lat)) || isNaN(parseFloat(s.lon))) return;
        const sLat = parseFloat(s.lat);
        const sLon = parseFloat(s.lon);
        window.L.circleMarker([sLat, sLon], {
          radius: 3,
          fillColor: color,
          color: '#fff',
          weight: 1,
          fillOpacity: 0.8
        }).addTo(layer).bindPopup(s.name);
      });
      
      state.stopDetailMapLayers[layerKey] = layer;
      layer.addTo(map);
    }
    
    // Apply current filter
    filterStopDetailMapLayers(state.stopViewFilteredRoutes);
  }
  
  // Update departures and re-render table/buttons (but not the whole view)
  const activeServices = getServicesForDate(state.selectedDate);
  const departures = [];
  const routesAtStop = new Map();
  
  state.gtfsData.routes.forEach(route => {
    const trips = state.gtfsData.tripsIndex[route.route_id] || [];
    trips.forEach(trip => {
      if (!activeServices.includes(trip.service_id)) return;
      const stopTimes = state.gtfsData.stopTimesIndex[trip.trip_id] || [];
      const stopTime = stopTimes.find(st => st.stop_id === state.selectedStop.stop_id);
      if (stopTime) {
        const departureTime = stopTime.departure_time || stopTime.arrival_time;
        if (departureTime) {
          departures.push({
            route: route,
            trip: trip,
            time: departureTime,
            timeMinutes: timeToMinutes(departureTime),
            headsign: trip.trip_headsign || ''
          });
          if (!routesAtStop.has(route.route_id)) routesAtStop.set(route.route_id, route);
        }
      }
    });
  });
  
  departures.sort((a, b) => a.timeMinutes - b.timeMinutes);
  state.stopDetailDepartures = departures;
  
  // Update UI
  updateDeparturesTable();
  updateRouteFilterButtons();
});

}
if (state.gtfsData && !state.selectedRoute && state.showStopsView && !state.selectedStop) renderStopsView();
if (state.gtfsData && state.selectedRoute) { 
  try {
    renderTimetable(); 
  } catch (err) {
    console.error('renderTimetable error:', err);
  }
  updateMap().catch(() => {
    // Ignore map update errors - map functionality is non-critical for timetable display
  }); 
}
}

    // Throttled render function to avoid excessive DOM updates during parsing
    function render(force = false) {
      const now = Date.now();
      
      // During loading, throttle renders to avoid excessive DOM updates
      if (state.loading && !force) {
        if (now - lastRenderTime < RENDER_THROTTLE_MS) {
          return; // Skip render if called too soon
        }
      }
      
      lastRenderTime = now;
      renderImmediate();
    }

// ═══════════════════════════════════════════════════════════════
// 15. GLOBAL EVENT HANDLERS & INITIALIZATION
// ═══════════════════════════════════════════════════════════════
    // global delegated handlers (one-time) ---------------------------------------------------------
    // handle clicks on any .route-link (works for badges in stop detail, modal, lists)
    document.addEventListener('click', (e) => {
      const routeLink = e.target.closest('.route-link');
      if (!routeLink) return;
      e.preventDefault();
      const routeId = routeLink.getAttribute('data-route-id');
      if (!routeId) return;
      const route = findRouteById(routeId);
      if (!route) return;
      selectRoute(route);
      // when navigating from stop view we want to leave stop view
      state.selectedStop = null;
      state.stopViewFilteredRoutes = [];
      resetMap();
      render();
    });

    // initial render
    render();
  </script>
</body>
</html>
